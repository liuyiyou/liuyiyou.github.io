<!DOCTYPE html>




<html class="theme-next pisces" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="java," />










<meta name="description" content="背景（Background）自从lambda表达式成为Java语言的一部分之后，Java集合（Collections）API就面临着大幅变化。而JSR 355（规定了Java lambda表达式的标准）的正式启用更是使得Java集合API变的过时不堪。尽管我们可以从头实现一个新的集合框架（比如“Collection II”），但取代现有的集合框架是一项非常艰难的工作，因为集合接口渗透了Java生态">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java8新特性-Lambda">
<meta property="og:url" content="http://liuyiyou.cn/2018-03-13-Java8新特性-Lambda/index.html">
<meta property="og:site_name" content="温故而知新    触类而旁通">
<meta property="og:description" content="背景（Background）自从lambda表达式成为Java语言的一部分之后，Java集合（Collections）API就面临着大幅变化。而JSR 355（规定了Java lambda表达式的标准）的正式启用更是使得Java集合API变的过时不堪。尽管我们可以从头实现一个新的集合框架（比如“Collection II”），但取代现有的集合框架是一项非常艰难的工作，因为集合接口渗透了Java生态">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-05-04T08:13:05.539Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java8新特性-Lambda">
<meta name="twitter:description" content="背景（Background）自从lambda表达式成为Java语言的一部分之后，Java集合（Collections）API就面临着大幅变化。而JSR 355（规定了Java lambda表达式的标准）的正式启用更是使得Java集合API变的过时不堪。尽管我们可以从头实现一个新的集合框架（比如“Collection II”），但取代现有的集合框架是一项非常艰难的工作，因为集合接口渗透了Java生态">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"right","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://liuyiyou.cn/2018-03-13-Java8新特性-Lambda/"/>





  <title>Java8新特性-Lambda | 温故而知新    触类而旁通</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">温故而知新    触类而旁通</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">In me the tiger Sniffs the rose</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-inbox">
          <a href="/inbox/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-inbox"></i> <br />
            
            收藏
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://liuyiyou.cn/2018-03-13-Java8新特性-Lambda/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liuyiyou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温故而知新    触类而旁通">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Java8新特性-Lambda</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-13T00:00:00+08:00">
                2018-03-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018-03-13-Java8新特性-Lambda/" class="leancloud_visitors" data-flag-title="Java8新特性-Lambda">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7,156
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  26
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="背景（Background）"><a href="#背景（Background）" class="headerlink" title="背景（Background）"></a>背景（Background）</h2><p>自从lambda表达式成为Java语言的一部分之后，Java集合（Collections）API就面临着大幅变化。而JSR 355（规定了Java lambda表达式的标准）的正式启用更是使得Java集合API变的过时不堪。尽管我们可以从头实现一个新的集合框架（比如“Collection II”），但取代现有的集合框架是一项非常艰难的工作，因为集合接口渗透了Java生态系统的每个角落，将它们一一换成新类库需要相当长的时间。因此，我们决定采取演化的策略（而非推倒重来）以改进集合API：</p>
<ul>
<li>为现有的接口（例如Collection，List和Stream）增加扩展方法；</li>
<li>在类库中增加新的流（stream，即java.util.stream.Stream）抽象以便进行聚集（aggregation）操作；</li>
<li>改造现有的类型使之可以提供流视图（stream view）；</li>
<li>改造现有的类型使之可以容易的使用新的编程模式，这样用户就不必抛弃使用以久的类库，例如ArrayList和HashMap（当然这并不是说集合API会常驻永存，毕竟集合API在设计之初</li>
</ul>
<p>并没有考虑到lambda表达式。我们可能会在未来的JDK中添加一个更现代的集合类库）。<br>除了上面的改进，还有一项重要工作就是提供更加易用的并行（Parallelism）库。尽管Java平台已经对并行和并发提供了强有力的支持，然而开发者在实际工作（将串行代码并行化）中仍然会碰到很多问题。因此，我们希望Java类库能够既便于编写串行代码也便于编写并行代码，因此我们把编程的重点从具体执行细节（how computation should be formed）转移到抽象执行步骤（what computation should be perfomed）。</p>
<p>除此之外，我们还需要在将并行变的容易（easier）和将并行变的不可见（invisible）之间做出抉择，我们选择了一个折中的路线：提供显式（explicit）但非侵入（unobstrusive）的并行。（如果把并行变的透明，那么很可能会引入不确定性（nondeterminism）以及各种数据竞争（data race）问题）</p>
<h2 id="内部迭代和外部迭代（Internal-vs-external-iteration）"><a href="#内部迭代和外部迭代（Internal-vs-external-iteration）" class="headerlink" title="内部迭代和外部迭代（Internal vs external iteration）"></a>内部迭代和外部迭代（Internal vs external iteration）</h2><p>集合类库主要依赖于外部迭代（externaliteration）。Collection实现Iterable接口，从而使得用户可以依次遍历集合的元素。比如我们需要把一个集合中的形状都设置成红色，那么可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Shape shape : shapes) &#123;</span><br><span class="line">  shape.setColor(RED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子演示了外部迭代：for-each循环调用shapes的iterator()方法进行依次遍历。外部循环的代码非常直接，但它有如下问题：</p>
<ul>
<li>Java的for循环是串行的，而且必须按照集合中元素的顺序进行依次处理；</li>
<li>集合框架无法对控制流进行优化，例如通过排序、并行、短路（short-circuiting）求值以及惰性求值改善性能。</li>
</ul>
<p>尽管有时for-each循环的这些特性（串行，依次）是我们所期待的，但它对改善性能造成了阻碍。<br>我们可以使用内部迭代（internal iteration）替代外部迭代，用户把对迭代的控制权交给类库，并向类库传递迭代时所需执行的代码。</p>
<p>下面是前例的内部迭代代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">shapes.forEach(s -&gt; s.setColor(RED));</span><br></pre></td></tr></table></figure>
<p>尽管看起来只是一个小小的语法改动，但是它们的实际差别非常巨大。用户把对操作的控制权交还给类库，从而允许类库进行各种各样的优化（例如乱序执行、惰性求值和并行等等）。总的来说，内部迭代使得外部迭代中不可能实现的优化成为可能。</p>
<p>外部迭代同时承担了做什么（把形状设为红色）和怎么做（得到Iterator实例然后依次遍历）两项职责，而内部迭代只负责做什么，而把怎么做留给类库。通过这样的职责转变：用户的代码会变得更加清晰，而类库则可以进行各种优化，从而使所有用户都从中受益。</p>
<h2 id="流（Stream）"><a href="#流（Stream）" class="headerlink" title="流（Stream）"></a>流（Stream）</h2><p>流是Java SE 8类库中新增的关键抽象，它被定义于java.util.stream（这个包里有若干流类型：Stream<t>代表对象引用流，此外还有一系列特化（specialization）流，比如IntStream代表整形数字流）。每个流代表一个值序列，流提供一系列常用的聚集操作，使得我们可以便捷的在它上面进行各种运算。集合类库也提供了便捷的方式使我们可以以操作流的方式使用集合、数组以及其它数据结构。<br>流的操作可以被组合成流水线（Pipeline）。以前面的例子为例，如果我们只想把蓝色改成红色：</t></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">shapes.stream()</span><br><span class="line">      .filter(s -&gt; s.getColor() == BLUE)</span><br><span class="line">      .forEach(s -&gt; s.setColor(RED));</span><br></pre></td></tr></table></figure>
<p>在Collection上调用stream()会生成该集合元素的流视图（stream view），接下来filter()操作会产生只包含蓝色形状的流，最后，这些蓝色形状会被forEach操作设为红色。<br>如果我们想把蓝色的形状提取到新的List里，则可以：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Shape&gt; blue = shapes.stream()</span><br><span class="line">                         .filter(s -&gt; s.getColor() == BLUE)</span><br><span class="line">                         .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>collect()操作会把其接收的元素聚集（aggregate）到一起（这里是List），collect()方法的参数则被用来指定如何进行聚集操作。在这里我们使用toList()<br>以把元素输出到List中。（如需更多collect()方法的细节，请阅读Collectors一节）<br>如果每个形状都被保存在Box里，然后我们想知道哪个盒子至少包含一个蓝色形状，我们可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Box&gt; hasBlueShape = shapes.stream()</span><br><span class="line">                              .filter(s -&gt; s.getColor() == BLUE)</span><br><span class="line">                              .map(s -&gt; s.getContainingBox())</span><br><span class="line">                              .collect(Collectors.toSet());</span><br></pre></td></tr></table></figure>
<p>map()操作通过映射函数（这里的映射函数接收一个形状，然后返回包含它的盒子）对输入流里面的元素进行依次转换，然后产生新流。</p>
<p>如果我们需要得到蓝色物体的总重量，我们可以这样表达：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = shapes.stream()</span><br><span class="line">                .filter(s -&gt; s.getColor() == BLUE)</span><br><span class="line">                .mapToInt(s -&gt; s.getWeight())</span><br><span class="line">                .sum();</span><br></pre></td></tr></table></figure>
<p>这些例子演示了流框架的设计，以及如何使用流框架解决实际问题。</p>
<h2 id="流和集合（Streams-vs-Collections）"><a href="#流和集合（Streams-vs-Collections）" class="headerlink" title="流和集合（Streams vs Collections）"></a>流和集合（Streams vs Collections）</h2><p>集合和流尽管在表面上看起来很相似，但它们的设计目标是不同的：集合主要用来对其元素进行有效（effective）的管理和访问（access），而流并不支持对其元素进行直接操作或直接访问，而只支持通过声明式操作在其上进行运算然后得到结果。除此之外，流和集合还有一些其它不同：</p>
<ul>
<li>无存储：流并不存储值；流的元素源自数据源（可能是某个数据结构、生成函数或I/O通道等等），通过一系列计算步骤得到；</li>
<li>天然的函数式风格（Functional in nature）：对流的操作会产生一个结果，但流的数据源不会被修改；</li>
<li>惰性求值：多数流操作（包括过滤、映射、排序以及去重）都可以以惰性方式实现。这使得我们可以用一遍遍历完成整个流水线操作，并可以用短路操作提供更高效的实现；</li>
<li>无需上界（Bounds optional）：不少问题都可以被表达为无限流（infinite stream）：用户不停地读取流直到满意的结果出现为止（比如说，枚举完美数这个操作可以被表达为在所有整数上进行过滤）。</li>
</ul>
<p>集合是有限的，但流不是（操作无限流时我们必需使用短路操作，以确保操作可以在有限时间内完成）；</p>
<p>从API的角度来看，流和集合完全互相独立，不过我们可以既把集合作为流的数据源（Collection拥有stream()和parallelStream()方法），也可以通过流产生一个集合（使用前例的collect()方法）。</p>
<p>Collection以外的类型也可以作为stream的数据源，比如JDK中的BufferedReader、Random和BitSet已经被改造可以用做流的数据源，Arrays.stream()则产生给定数组的流视图。事实上，任何可以用Iterator描述的对象都可以成为流的数据源，如果有额外的信息（比如大小、是否有序等特性），库还可以进行进一步的优化。</p>
<h2 id="惰性（Laziness）"><a href="#惰性（Laziness）" class="headerlink" title="惰性（Laziness）"></a>惰性（Laziness）</h2><p>过滤和映射这样的操作既可以被急性求值（以filter为例，急性求值需要在方法返回前完成对所有元素的过滤），也可以被惰性求值（用Stream代表过滤结果，当且仅当需要时才进行过滤操作）在实际中进行惰性运算可以带来很多好处。比如说，如果我们进行惰性过滤，我们就可以把过滤和流水线里的其它操作混合在一起，从而不需要对数据进行多遍遍历。相类似的，如果我们在一个大型集合里搜索第一个满足某个条件的元素，我们可以在找到后直接停止，而不是继续处理整个集合。（这一点对无限数据源是很重要，惰性求值对于有限数据源起到的是优化作用，但对无限数据源起到的是决定作用，没有惰性求值，对无限数据源的操作将无法终止）<br>对于过滤和映射这样的操作，我们很自然的会把它当成是惰性求值操作，不过它们是否真的是惰性取决于它们的具体实现。另外，像sum()这样生成值的操作和forEach()这样产生副作用的操作都是“天然急性求值”，因为它们必须要产生具体的结果。</p>
<p>以下面的流水线为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = shapes.stream()</span><br><span class="line">                .filter(s -&gt; s.getColor() == BLUE)</span><br><span class="line">                .mapToInt(s -&gt; s.getWeight())</span><br><span class="line">                .sum();</span><br></pre></td></tr></table></figure>
<p>这里的过滤操作和映射操作是惰性的，这意味着在调用sum()之前，我们不会从数据源提取任何元素。在sum操作开始之后，我们把过滤、映射以及求和混合在对数据源的一遍遍历之中。这样可以大大减少维持中间结果所带来的开销。<br>大多数循环都可以用数据源（数组、集合、生成函数以及I/O管道）上的聚合操作来表示：进行一系列惰性操作（过滤和映射等操作），然后用一个急性求值操作（forEach，toArray和collect等操作）得到最终结果——例如过滤—映射—累积，过滤—映射—排序—遍历等组合操作。惰性操作一般被用来计算中间结果，这在Streams API设计中得到了很好的体现——与其让filter和map返回一个集合，我们选择让它们返回一个新的流。在Streams API中，返回流对象的操作都是惰性操作，而返回非流对象的操作（或者无返回值的操作，例如forEach()）都是急性操作。</p>
<p>绝大多数情况下，潜在的惰性操作会被用于聚合，这正是我们想要的——流水线中的每一轮操作都会接收输入流中的元素，进行转换，然后把转换结果传给下一轮操作。<br>在使用这种数据源—惰性操作—惰性操作—急性操作流水线时，流水线中的惰性几乎是不可见的，因为计算过程被夹在数据源和最终结果（或副作用操作）之间。这使得API的可用性和性能得到了改善。<br>对于anyMatch(Predicate)和findFirst()这些急性求值操作，我们可以使用短路（short-circuiting）来终止不必要的运算。以下面的流水线为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Shape&gt; firstBlue = shapes.stream()</span><br><span class="line">                                  .filter(s -&gt; s.getColor() == BLUE)</span><br><span class="line">                                  .findFirst();</span><br></pre></td></tr></table></figure>
<p>由于过滤这一步是惰性的，findFirst在从其上游得到一个元素之后就会终止，这意味着我们只会处理这个元素及其之前的元素，而不是所有元素。findFirst()方法返回Optional对象，因为集合中有可能不存在满足条件的元素。Optional是一种用于描述可缺失值的类型。<br>在这种设计下，用户并不需要显式进行惰性求值，甚至他们都不需要了解惰性求值。类库自己会选择最优化的计算方式。</p>
<h2 id="并行（Parallelism）"><a href="#并行（Parallelism）" class="headerlink" title="并行（Parallelism）"></a>并行（Parallelism）</h2><p>流水线既可以串行执行也可以并行执行，并行或串行是流的属性。除非你显式要求使用并行流，否则JDK总会返回串行流。（串行流可以通过parallel()方法被转化为并行流）<br>尽管并行是显式的，但它并不需要成为侵入式的。利用parallelStream()，我们可以轻松的把之前重量求和的代码并行化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = shapes.parallelStream()</span><br><span class="line">                .filter(s -&gt; s.getColor = BLUE)</span><br><span class="line">                .mapToInt(s -&gt; s.getWeight())</span><br><span class="line">                .sum();</span><br></pre></td></tr></table></figure>
<p>并行化之后和之前的代码区别并不大，然而我们可以很容易看出它是并行的（此外我们并不需要自己去实现并行代码）。<br>因为流的数据源可能是一个可变集合，如果在遍历流时数据源被修改，就会产生干扰（interference）。所以在进行流操作时，流的数据源应保持不变（held constant）。这个条件并不难维持，如果集合只属于当前线程，只要lambda表达式不修改流的数据源就可以。（这个条件和遍历集合时所需的条件相似，如果集合在遍历时被修改，绝大多数的集合实现都会抛出ConcurrentModificationException）我们把这个条件称为无干扰性（non-interference）。</p>
<p>我们应避免在传递给流方法的lambda产生副作用。一般来说，打印调试语句这种输出变量的操作是安全的，然而在lambda表达式里访问可变变量就有可能造成数据竞争或是其它意想不到的问题，因为lambda在执行时可能会同时运行在多个线程上，因而它们所看到的元素有可能和正常的顺序不一致。无干扰性有两层含义：</p>
<ol>
<li>不要干扰数据源；</li>
<li>不要干扰其它lambda表达式，当一个lambda在修改某个可变状态而另一个lambda在读取该状态时就会产生这种干扰。</li>
</ol>
<p>只要满足无干扰性，我们就可以安全的进行并行操作并得到可预测的结果，即便对线程不安全的集合（例如ArrayList）也是一样。</p>
<p>实例（Examples）</p>
<p>下面的代码源自JDK中的Class类型（getEnclosingMethod方法），这段代码会遍历所有声明的方法，然后根据方法名称、返回类型以及参数的数量和类型进行匹配：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Method method : enclosingInfo.getEnclosingClass().getDeclaredMethods()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (method.getName().equals(enclosingInfo.getName())) &#123;</span><br><span class="line">    Class&lt; ? &gt;[] candidateParamClasses = method.getParameterTypes();</span><br><span class="line">    <span class="keyword">if</span> (candidateParamClasses.length == parameterClasses.length) &#123;</span><br><span class="line">      <span class="keyword">boolean</span> matches = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; candidateParamClasses.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!candidateParamClasses[i].equals(parameterClasses[i])) &#123;</span><br><span class="line">          matches = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (matches) &#123; <span class="comment">// finally, check return type</span></span><br><span class="line">        <span class="keyword">if</span> (method.getReturnType().equals(returnType)) &#123;</span><br><span class="line">          <span class="keyword">return</span> method;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Enclosing method not found"</span>);</span><br></pre></td></tr></table></figure>
<p>通过使用流，我们不但可以消除上面代码里面所有的临时变量，还可以把控制逻辑交给类库处理。通过反射得到方法列表之后，我们利用Arrays.stream将它转化为Stream，然后利用一系列过滤器去除类型不符、参数不符以及返回值不符的方法，然后通过调用findFirst得到Optional<method>，最后利用orElseThrow返回目标值或者抛出异常。</method></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> Arrays.stream(enclosingInfo.getEnclosingClass().getDeclaredMethods())</span><br><span class="line">             .filter(m -&gt; Objects.equal(m.getName(), enclosingInfo.getName()))</span><br><span class="line">             .filter(m -&gt; Arrays.equal(m.getParameterTypes(), parameterClasses))</span><br><span class="line">             .filter(m -&gt; Objects.equals(m.getReturnType(), returnType))</span><br><span class="line">             .findFirst()</span><br><span class="line">             .orElseThrow(() -&gt; <span class="keyword">new</span> InternalError(<span class="string">"Enclosing method not found"</span>));</span><br></pre></td></tr></table></figure>
<p>相对于未使用流的代码，这段代码更加紧凑，可读性更好，也不容易出错。<br>流操作特别适合对集合进行查询操作。假设有一个“音乐库”应用，这个应用里每个库都有一个专辑列表，每张专辑都有其名称和音轨列表，每首音轨表都有名称、艺术家和评分。<br>假设我们需要得到一个按名字排序的专辑列表，专辑列表里面的每张专辑都至少包含一首四星及四星以上的音轨，为了构建这个专辑列表，我们可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Album&gt; favs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Album album : albums) &#123;</span><br><span class="line">  <span class="keyword">boolean</span> hasFavorite = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (Track track : album.tracks) &#123;</span><br><span class="line">    <span class="keyword">if</span> (track.rating &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">      hasFavorite = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (hasFavorite)</span><br><span class="line">    favs.add(album);</span><br><span class="line">&#125;</span><br><span class="line">Collections.sort(favs, <span class="keyword">new</span> Comparator&lt;Album&gt;() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Album a1, Album a2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a1.name.compareTo(a2.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们可以用流操作来完成上面代码中的三个主要步骤——识别一张专辑是否包含一首评分大于等于四星的音轨（使用anyMatch）；按名字排序；以及把满足条件的专辑放在一个List中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Album&gt; sortedFavs =</span><br><span class="line">    albums.stream()</span><br><span class="line">          .filter(a -&gt; a.tracks.anyMatch(t -&gt; (t.rating &gt;= <span class="number">4</span>)))</span><br><span class="line">          .sorted(Comparator.comparing(a -&gt; a.name))</span><br><span class="line">          .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>Compartor.comparing方法接收一个函数（该函数返回一个实现了Comparable接口的排序键值），然后返回一个利用该键值进行排序的Comparator（请参考下面的比较器工厂一节）。</p>
<h2 id="收集器（Collectors）"><a href="#收集器（Collectors）" class="headerlink" title="收集器（Collectors）"></a>收集器（Collectors）</h2><p>在之前的例子中，我们利用collect()方法把流中的元素聚合到List或Set中。collect()接收一个类型为Collector的参数，这个参数决定了如何把流中的元素聚合到其它数据结构中。Collectors类包含了大量常用收集器的工厂方法，toList()和toSet()就是其中最常见的两个，除了它们还有很多收集器，用来对数据进行对复杂的转换。<br>Collector的类型由其输入类型和输出类型决定。以toList()收集器为例，它的输入类型为T，输出类型为List<t>，toMap是另外一个较为复杂的Collector，它有若干个版本。最简单的版本接收一对函数作为输入，其中一个函数用来生成键（key），另一个函数用来生成值（value）。toMap的输入类型是T，输出类型是Map<k, v="">，其中K和V分别是前面两个函数所生成的键类型和值类型。（复杂版本的toMap收集器则允许你指定目标Map的类型或解决键冲突）。举例来说，下面的代码以目录数字为键值创建一个倒排索引：</k,></t></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Album&gt; albumsByCatalogNumber =</span><br><span class="line">    albums.stream()</span><br><span class="line">          .collect(Collectors.toMap(a -&gt; a.getCatalogNumber(), a -&gt; a));</span><br></pre></td></tr></table></figure>
<p>groupingBy是一个与toMap相类似的收集器，比如说我们想要把我们最喜欢的音乐按歌手列出来，这时我们就需要这样的Collector：它以Track作为输入，以Map<artist, list<track="">&gt;</artist,></p>
<p>作为输出。groupingBy收集器就可以胜任这个工作，它接收分类函数（classification function），然后根据这个函数生成Map，该Map的键是分类函数的返回结果，值是该分类下的元素列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Artist, List&lt;Track&gt;&gt; favsByArtist =</span><br><span class="line">    tracks.stream()</span><br><span class="line">          .filter(t -&gt; t.rating &gt;= <span class="number">4</span>)</span><br><span class="line">          .collect(Collectors.groupingBy(t -&gt; t.artist));</span><br></pre></td></tr></table></figure>
<p>收集器可以通过组合和复用来生成更加复杂的收集器，简单版本的groupingBy收集器把元素按照分类函数为每个元素计算出分类键值，然后把输入元素输出到对应的分类列表中。除了这个版本，还有一个更加通用（general）的版本允许你使用其它收集器来整理输入元素：它接收一个分类函数以及一个下流（downstream）收集器（单参数版本的groupingBy使用toList()作为其默认下流收集器）。举例来说，如果我们想把每首歌曲的演唱者收集到Set而非List中，我们可以使用toSet收集器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Artist, Set&lt;Track&gt;&gt; favsByArtist =</span><br><span class="line">    tracks.stream()</span><br><span class="line">          .filter(t -&gt; t.rating &gt;= <span class="number">4</span>)</span><br><span class="line">          .collect(Collectors.groupingBy(t -&gt; t.artist,</span><br><span class="line">                                         Collectors.toSet()));</span><br></pre></td></tr></table></figure>
<p>如果我们需要按照歌手和评分来管理歌曲，我们可以生成多级Map：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Artist, Map&lt;Integer, List&lt;Track&gt;&gt;&gt; byArtistAndRating =</span><br><span class="line">    tracks.stream()</span><br><span class="line">          .collect(groupingBy(t -&gt; t.artist,</span><br><span class="line">                              groupingBy(t -&gt; t.rating)));</span><br></pre></td></tr></table></figure>
<p>在最后的例子里，我们创建了一个歌曲标题里面的词频分布。我们首先使用Stream.flatMap()得到一个歌曲流，然后用Pattern.splitAsStream把每首歌曲的标题打散成词流；接下来我们用groupingBy和String.toUpperCase对这些词进行不区分大小写的分组，最后使用counting()收集器计算每个词出现的次数（从而无需创建中间集合）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pattern pattern = Pattern.compile(<span class="string">"\\s+"</span>);</span><br><span class="line">Map&lt;String, Integer&gt; wordFreq =</span><br><span class="line">    tracks.stream()</span><br><span class="line">          .flatMap(t -&gt; pattern.splitAsStream(t.name)) <span class="comment">// Stream&lt;String&gt;</span></span><br><span class="line">          .collect(groupingBy(s -&gt; s.toUpperCase(),counting()));</span><br></pre></td></tr></table></figure>
<p>flatMap接收一个返回流（这里是歌曲标题里的词）的函数。它利用这个函数将输入流中的每个元素转换为对应的流，然后把这些流拼接到一个流中。所以上面代码中的flatMap会返回所有歌曲标题里面的词，接下来我们不区分大小写的把这些词分组，并把词频作为值（value）储存。<br>Collectors类包含大量的方法，这些方法被用来创造各式各样的收集器，以便进行查询、列表（tabulation）和分组等工作，当然你也可以实现一个自定义Collector。<br>并行的实质（Parallelism under the hood）<br>Java SE 7引入了Fork/Join模型，以便高效实现并行计算。不过，通过Fork/Join编写的并行代码和同功能的串行代码的差别非常巨大，这使改写串行代码变的非常困难。通过提供串行流和并行流，用户可以在串行操作和并行操作之间进行便捷的切换（无需重写代码），从而使得编写正确的并行代码变的更加容易。</p>
<p>为了实现并行计算，我们一般要把计算过程递归分解（recursive decompose）为若干步：</p>
<ul>
<li>把问题分解为子问题；</li>
<li>串行解决子问题从而得到部分结果（partial result）；</li>
<li>合并部分结果合为最终结果。</li>
</ul>
<p>这也是Fork/Join的实现原理。<br>为了能够并行化任意流上的所有操作，我们把流抽象为Spliterator，Spliterator是对传统迭代器概念的一个泛化。分割迭代器（spliterator）既支持顺序依次访问数据，也支持分解数据：就像Iterator允许你跳过一个元素然后保留剩下的元素，Spliterator允许你把输入元素的一部分（一般来说是一半）转移（carve off）到另一个新的Spliterator中，而剩下的数据则会被保存在原来的Spliterator里。（这两个分割迭代器还可以被进一步分解）除此之外，分割迭代器还可以提供源的元数据（比如元素的数量，如果已知的话）和其它一系列布尔值特征（比如说“元素是否被排序”这样的特征），Streams框架可以利用这些数据来进行优化。</p>
<p>上面的分解方法也同样适用于其它数据结构，数据结构的作者只需要提供分解逻辑，然后就可以直接享用并行流操作带来的遍历。<br>大多数用户无需去实现Spliterator接口，因为集合上的stream()方法往往就足够了。但如果你需要实现一个集合或一个流，那么你可能需要手动实现Spliterator接口。Spliterator接口的API如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Spliterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// Element access</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt; ? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt; ? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Decomposition</span></span><br><span class="line">  <span class="function">Spliterator&lt;T&gt; <span class="title">trySplit</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//Optional metadata</span></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span></span>;</span><br><span class="line">  Comparator&lt; ? <span class="keyword">super</span> T&gt; getComparator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>集合库中的基础接口Collection和Iterable都实现了正确但相对低效的spliterator()实现，但派生接口（例如Set）和具体实现类（例如ArrayList）均提供了高效的分割迭代器实现。分割迭代器的实现质量会影响到流操作的执行效率；如果在split()方法中进行良好（平衡）的划分，CPU的利用率会得到改善；此外，提供正确的特性（characteristics）和大小（size）这些元数据有利于进一步优化。</p>
<h2 id="出现顺序（Encounter-order）"><a href="#出现顺序（Encounter-order）" class="headerlink" title="出现顺序（Encounter order）"></a>出现顺序（Encounter order）</h2><p>多数数据结构（例如列表，数组和I/O通道）都拥有自然出现顺序（natural encounter order），这意味着它们的元素出现顺序是可预测的。其它的数据结构（例如HashSet）则没有一个明确定义的出现顺序（这也是HashSet的Iterator实现中不保证元素出现顺序的原因）。<br>是否具有明确定义的出现顺序是Spliterator检查的特性之一（这个特性也被流使用）。除了少数例外（比如Stream.forEach()和Stream.findAny()），并行操作一般都会受到出现顺序的限制。这意味着下面的流水线：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = people.parallelStream()</span><br><span class="line">                           .map(Person::getName)</span><br><span class="line">                           .collect(toList());</span><br></pre></td></tr></table></figure>
<p>代码中名字出现的顺序必须要和流中的Person出现的顺序一致。一般来说，这是我们所期待的结果，而且它对多大多数的流实现都不会造成明显的性能损耗。从另外的角度来说，如果源数据是HashSet，那么上面代码中名字就可以以任意顺序出现。</p>
<h2 id="JDK中的流和lambda（Streams-and-lambdas-in-JDK）"><a href="#JDK中的流和lambda（Streams-and-lambdas-in-JDK）" class="headerlink" title="JDK中的流和lambda（Streams and lambdas in JDK）"></a>JDK中的流和lambda（Streams and lambdas in JDK）</h2><p>Stream在Java SE 8中非常重要，我们希望可以在JDK中尽可能广的使用Stream。我们为Collection提供了stream()和parallelStream()，以便把集合转化为流；此外数组可以通过Arrays.stream()被转化为流。<br>除此之外，Stream中还有一些静态工厂方法（以及相关的原始类型流实现），这些方法被用来创建流，例如Stream.of()，Stream.generate以及IntStream.range。其它的常用类型也提供了流相关的方法，例如String.chars，BufferedReader.lines，Pattern.splitAsStream，Random.ints和BitSet.stream。<br>最后，我们提供了一系列API用于构建流，类库的编写者可以利用这些API来在流上实现其它聚集操作。实现Stream至少需要一个Iterator，不过如果编写者还拥有其它元数据（例如数据大小），类库就可以通过Spliterator提供一个更加高效的实现（就像JDK中所有的集合一样）。</p>
<h2 id="比较器工厂（Comparator-factories）"><a href="#比较器工厂（Comparator-factories）" class="headerlink" title="比较器工厂（Comparator factories）"></a>比较器工厂（Comparator factories）</h2><p>我们在Comparator接口中新增了若干用于生成比较器的实用方法：<br>静态方法Comparator.comparing()接收一个函数（该函数返回一个实现Comparable接口的比较键值），返回一个Comparator，它的实现十分简洁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U extends Comparable&lt; ? <span class="keyword">super</span> U&gt;&gt; <span class="function">Compartor&lt;T&gt; <span class="title">comparing</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Function&lt; ? <span class="keyword">super</span> T, ? extends U&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (c1, c2) -&gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把这种方法称为高阶函数——以函数作为参数或是返回值的函数。我们可以使用高阶函数简化代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; people = ...</span><br><span class="line">people.sort(comparing(p -&gt; p.getLastName()));</span><br></pre></td></tr></table></figure>
<p>这段代码比“过去的代码”（一般要定义一个实现Comparator接口的匿名类）要简洁很多。但是它真正的威力在于它大大改进了可组合性（composability）。举例来说，Comparator拥有一个用于逆序的默认方法。于是，如果想把列表按照姓进行反序排序，我们只需要创建一个和之前一样的比较器，然后调用反序方法即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">people.sort(comparing(p -&gt; p.getLastName()).reversed());</span><br></pre></td></tr></table></figure>
<p>与之类似，默认方法thenComparing允许你去改进一个已有的Comparator：在原比较器返回相等的结果时进行进一步比较。下面的代码演示了如何按照姓和名进行排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Person&gt; c = Comparator.comparing(p -&gt; p.getLastName())</span><br><span class="line">                                 .thenComparing(p -&gt; p.getFirstName());</span><br><span class="line">people.sort(c);</span><br></pre></td></tr></table></figure>
<p>可变的集合操作（Mutative collection operation）<br>集合上的流操作一般会生成一个新的值或集合。不过有时我们希望就地修改集合，所以我们为集合（例如Collection，List和Map）提供了一些新的方法，比如Iterable.forEach(Consumer)，Collection.removeAll(Predicate)，List.replaceAll(UnaryOperator)，List.sort(Comparator)和Map.computeIfAbsent()。除此之外，ConcurrentMap中的一些非原子方法（例如replace和putIfAbsent）被提升到Map之中。</p>
<h2 id="小结（Summary）"><a href="#小结（Summary）" class="headerlink" title="小结（Summary）"></a>小结（Summary）</h2><p>引入lambda表达式是Java语言的巨大进步，但这还不够——开发者每天都要使用核心类库，为了开发者能够尽可能方便的使用语言的新特性，语言的演化和类库的演化是不可分割的。Stream抽象作为新增类库特性的核心，提供了强大的数据集合操作功能，并被深入整合到现有的集合类和其它的JDK类型中。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018-03-13-Autowired的一些解惑/" rel="next" title="Autowired的一些解惑">
                <i class="fa fa-chevron-left"></i> Autowired的一些解惑
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018-03-14-Java8新特性/" rel="prev" title="Java8新特性">
                Java8新特性 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">liuyiyou</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">165</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#背景（Background）"><span class="nav-number">1.</span> <span class="nav-text">背景（Background）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内部迭代和外部迭代（Internal-vs-external-iteration）"><span class="nav-number">2.</span> <span class="nav-text">内部迭代和外部迭代（Internal vs external iteration）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流（Stream）"><span class="nav-number">3.</span> <span class="nav-text">流（Stream）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流和集合（Streams-vs-Collections）"><span class="nav-number">4.</span> <span class="nav-text">流和集合（Streams vs Collections）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#惰性（Laziness）"><span class="nav-number">5.</span> <span class="nav-text">惰性（Laziness）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并行（Parallelism）"><span class="nav-number">6.</span> <span class="nav-text">并行（Parallelism）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#收集器（Collectors）"><span class="nav-number">7.</span> <span class="nav-text">收集器（Collectors）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#出现顺序（Encounter-order）"><span class="nav-number">8.</span> <span class="nav-text">出现顺序（Encounter order）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK中的流和lambda（Streams-and-lambdas-in-JDK）"><span class="nav-number">9.</span> <span class="nav-text">JDK中的流和lambda（Streams and lambdas in JDK）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#比较器工厂（Comparator-factories）"><span class="nav-number">10.</span> <span class="nav-text">比较器工厂（Comparator factories）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结（Summary）"><span class="nav-number">11.</span> <span class="nav-text">小结（Summary）</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2012 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liuyiyou.cn</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">网站字数总数&#58;</span>
    
    <span title="网站字数总数">121.4k</span>
  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>




















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("FUPssgG7FQe5trsvf4TbpNfC-gzGzoHsz", "mRbmufFxoH0YiK3CPTPzpvS7");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
    
  </script>

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  


<!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->

<!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
</body>
</html>
