{"meta":{"title":"温故而知新    触类而旁通","subtitle":"In me the tiger Sniffs the rose","description":"温故而知新、触类而旁通","author":"liuyiyou","url":"http://liuyiyou.cn","root":"/"},"pages":[{"title":"分类","date":"2014-12-22T04:39:04.000Z","updated":"2017-04-14T03:25:16.000Z","comments":true,"path":"categories/index.html","permalink":"http://liuyiyou.cn/categories/index.html","excerpt":"","text":""},{"title":"收藏","date":"2015-10-26T14:37:55.000Z","updated":"2019-01-29T09:32:34.898Z","comments":true,"path":"inbox/index.html","permalink":"http://liuyiyou.cn/inbox/index.html","excerpt":"","text":"后台模板基于 Ant Design of Vue 实现的 Ant Design Pro Vue 版轮子 其他Spring资料大全 : 持续更新 OSX软件的安装 ：这个是我自己汇总的，包含很多常用软件或者工具的安装 自己总结的SpringBoot&amp;SpringCloud系列 深入剖析Spring Web源码 Git在线书籍 是一个完整的书籍 Java虚拟机详解 Java NIO Tiny-Spring ：这个对了解Spring源码比价有用 Mysql-Proxy ：可以解决本地无法连接线上数据库，转而通过代理来连接的问题 Elasticsearch权威指南 美团点评数据仓库开发模式演进 github明星项目 ：可以关注一下最热最火的项目 shiro官方教程 effecttive-java读书笔记"},{"title":"分类","date":"2014-12-22T04:39:04.000Z","updated":"2017-04-14T03:30:30.000Z","comments":true,"path":"tags/index.html","permalink":"http://liuyiyou.cn/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-04-03T05:59:45.587Z","updated":"2019-04-03T03:19:40.896Z","comments":false,"path":"repository/index.html","permalink":"http://liuyiyou.cn/repository/index.html","excerpt":"","text":""},{"title":"书单","date":"2019-04-03T06:01:05.865Z","updated":"2019-04-03T03:19:40.895Z","comments":false,"path":"books/index.html","permalink":"http://liuyiyou.cn/books/index.html","excerpt":"","text":""},{"title":"关于我","date":"2015-10-26T14:37:55.000Z","updated":"2017-12-15T01:52:02.446Z","comments":true,"path":"about/index.html","permalink":"http://liuyiyou.cn/about/index.html","excerpt":"","text":"联系方式 Email：liuyiyou_cn@qq.com 二维码:"}],"posts":[{"title":"希尔排序","slug":"2015-01-06-希尔排序","date":"2015-01-06T00:00:00.000Z","updated":"2018-01-19T04:00:02.915Z","comments":true,"path":"2015-01-06-希尔排序/","link":"","permalink":"http://liuyiyou.cn/2015-01-06-希尔排序/","excerpt":"","text":"概述希尔排序和直接插入排序一样，都是插入排序，但是它改进了直接插入排序，该方法又称缩小增量排序 算法原理希尔算法的运作如下：（从后往前） 先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内部进行直接插入排序，然后，取第二个增量d2&lt;d1重复上述分组和排序，直至所取的增量dt＝1，即所有记录放在同一组中进行直接插入排序为止。 一般的初次取序列的一半为增量，以后每次减半，直到增量为1。 ##算法流程图 算法分析时间复杂度希尔排序的时间复杂度和增量选取有关，如使用希尔增量时间复杂度为$$O(n^2)$$ ，而Hibbaard增量的希尔排序的时间复杂度为$$O(n^\\frac{3}{2})$$ ,希尔排序时间复杂度下届是$$nlog2n$$。希尔排序没有快速排序算法快$$O(nlogn)$$ 算法稳定性由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。 和直接排序进行比较来看一下希尔排序和快速排序的差别和联系 会发现基本思想和直接插入排序一模一样，只是多了一个曾脸的变化，即外面的while循环和那个increment = increment /2 //直接插入排序public static void insertSort1(int[] array) &#123; //从位置1开始，0做为哨兵 for (int i = 1; i &lt; array.length; i++) &#123; //保存当前位置到临时变量 int temp = array[i]; //将当前位置赋给紧邻的未排序的起点 int j = i; //如果未排序的数小于已排序的树 if (array[i - 1] &gt; array[i]) &#123; //向后移动一个位置 while (j &gt; 0 &amp;&amp; array[j - 1] &gt; temp) &#123; //只能是temp，不能是array[i] ,如果是array[i],在执行下面这句话的时候，array[i]会改的值被改变了 array[j] = array[j - 1]; j--; &#125; //将当前位置存放为i array[j] = temp; //同上，比如i为1的时候array[i]=3，array[j-1]为1，执行while里面的前移之后，array[j]=array[i]=3.而实际的情况应该是array[j] &#125; else &#123; System.out.println(i); &#125; &#125; &#125;//希尔排序public static void shellSort1(int[] array)&#123; //增量 ,初始一般为数组的一半，最后为1 int increment = array.length/2; //控制增量变化，一直到1 while (increment&gt;0)&#123; for (int i = increment ; i &lt; array.length; i++)&#123; //保存当前位置到临时变量 int temp = array[i]; //将当前位置赋给紧邻的未排序的起点 int j = i; //如果未排序的数小于已排序的树 if (array[i-increment]&gt;array[i])&#123; //向后移动increment个位置 while (j&gt;=increment &amp;&amp; array[j-increment]&gt; temp)&#123; array[j] = array[j-increment]; j = j - increment; &#125; //将当前位置存放为i array[j] = temp; //同上，比如i为1的时候array[i]=3，array[j-1]为1，执行while里面的前移之后，array[j]=array[i]=3.而实际的情况应该是array[j] &#125; else &#123; System.out.println(i); &#125; &#125; //增量为上一次的一半。因为是int类型，所以最后会到1（0就不进行除了） increment = increment/2; &#125; &#125; ###算法描述 package cn.liuyiyou.sort;/** * User: liuyiyou * Date: 13-1-1 * Time: 下午8:16 */public class ShellSort &#123; /** * 这个可以和前面的快速插入排序进行比较，会发现方法一模一样，只是快速插入的增量一直为1.而希尔排序增量是慢慢变小的。 * */ public static void shellSort1(int[] array)&#123; int increment = array.length/2; while (increment&gt;0)&#123; for (int i = increment ; i &lt; array.length; i++)&#123; int temp = array[i]; int j = i; if (array[i-increment]&gt;array[i])&#123; while (j&gt;=increment &amp;&amp; array[j-increment]&gt; temp)&#123; array[j] = array[j-increment]; j = j - increment; &#125; array[j] = temp; &#125; else &#123; System.out.println(i); &#125; &#125; increment = increment/2; &#125; &#125; public static void shellSort2(int[] array) &#123; int count = 0; int j = 0; int temp = 0; for (int increment = array.length / 2; increment &gt; 0; increment /= 2) &#123; count++; for (int i = increment; i &lt; array.length; i++) &#123; temp = array[i]; for (j = i; j &gt;= increment; j -= increment) &#123; if(temp &gt; array[j - increment])&#123; array[j] = array[j - increment]; &#125;else&#123; break; &#125; &#125; array[j] = temp; &#125; &#125; System.out.println(count); &#125; public static void shellSort3(int[] array) &#123; int j = 0; int temp = 0; int increment = array.length/2; while (increment&gt;0)&#123; for (int i = increment; i &lt; array.length; i++) &#123; temp = array[i]; j = i; while (j &gt;= increment) &#123; if(temp &gt; array[j - increment])&#123; array[j] = array[j - increment]; &#125;else&#123; break; &#125; j = j - increment; &#125; array[j] = temp; &#125; increment = increment/2; &#125; &#125; public static void main(String[] args) &#123; int [] array = SortUtil.array; System.out.println(\"原始排序结果：\"); SortUtil.print(array); shellSort1(array); System.out.println(\"最终排序结果：\"); SortUtil.print(array); &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/tags/数据结构/"}]},{"title":"快速排序","slug":"2015-01-05-快速排序","date":"2015-01-05T00:00:00.000Z","updated":"2018-01-19T04:00:02.915Z","comments":true,"path":"2015-01-05-快速排序/","link":"","permalink":"http://liuyiyou.cn/2015-01-05-快速排序/","excerpt":"","text":"概述通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 算法原理通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 算法流程图动画演示:排序过程 算法分析时间复杂度时间复杂度：O（n*lgn） 最坏：O（n^2） 空间复杂度：O（n*lgn） 算法稳定性不稳定。 代码","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/tags/数据结构/"}]},{"title":"选择排序","slug":"2015-01-03-选择排序","date":"2015-01-03T00:00:00.000Z","updated":"2019-02-10T11:01:10.769Z","comments":true,"path":"2015-01-03-选择排序/","link":"","permalink":"http://liuyiyou.cn/2015-01-03-选择排序/","excerpt":"","text":"概述选择排序：每一趟从待排序的数据元素中选出最小（或最大）的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。 原理：选择排序很简单，他的步骤如下： 从左至右遍历，找到最小(大)的元素，然后与第一个元素交换。 从剩余未排序元素中继续寻找最小（大）元素，然后与第二个元素进行交换。 以此类推，直到所有元素均排序完毕。 动画演示: 具体的排序过程 算法分析时间复杂度若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数$$C$$和记录移动次数$$M$$均达到最小值:$$C_{min}=n-1$$,$$M_{min}=0$$。所以，冒泡排序最好的时间复杂度为$$O(n)$$ 。 若初始文件是反序的，需要进行$$n-1$$趟排序。每趟排序要进行$$n-i$$次关键字的比较($$1≤i≤n-1$$),且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值： $$C_{max} = \\left(n(n-1)\\over 2 \\right) = O(n^2)$$ $$M_{max} = \\frac{3n(n-1)}{2} = O(n^2)$$ 冒泡排序的最坏时间复杂度为$$O(n^2)$$ 。 综上，因此冒泡排序总的平均时间复杂度为$$O(n^2)$$ 分析 选择排序需要花费 (N – 1) + (N – 2) + … + 1 + 0 = N(N- 1) / 2 ~ N2/2次比较 和 N-1次交换操作。 对初始数据不敏感，不管初始的数据有没有排好序，都需要经历N2/2次比较，这对于一些原本排好序，或者近似排好序的序列来说并不具有优势。在最好的情况下，即所有的排好序，需要0次交换，最差的情况，倒序，需要N-1次交换。 数据交换的次数较少，如果某个元素位于正确的最终位置上，则它不会被移动。在最差情况下也只需要进行N-1次数据交换，在所有的完全依靠交换去移动元素的排序方法中，选择排序属于比较好的一种。 算法稳定性不稳定 算法实现可以分为两大部分： 找到待排序数组中第i小的元素 将该元素与i处的元素进行交换 public static int findMinIndex(int[] array, int i) &#123; int minIndex = i; for (int j = i + 1; j &lt; array.length; j++) &#123; if (array[minIndex] &gt; array[j]) &#123; minIndex = j; &#125; &#125; System.out.println(\"第\" + (i) + \"小的\" + array[minIndex]); return minIndex; &#125;public static void swap(int[] array, int i, int minIndex) &#123; int temp = array[i]; array[i] = array[minIndex]; array[minIndex] = temp; &#125;public static void selectSort2(int[] array) &#123; for (int i = 0; i &lt; array.length; i++) &#123; int minIndex = findMinIndex(array, i); swap(array, i, minIndex); &#125; &#125; package cn.liuyiyou.sort;// 每一趟从待排序的数据元素中选出最小（或最大）的一个元素，顺序放在已排好序的数列的最后，//直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。public class SelectSort &#123; public static void selectSort3(int[] array) &#123; for (int i = 0; i &lt; array.length; i++) &#123; //默认当前位置最小 int minIndex = i; for (int j = i + 1; j &lt; array.length; j++) &#123; //如果未排序的元素比当前元素小，则将该元素的索引赋给最小元素的索引 if (array[minIndex] &gt; array[j]) minIndex = j; &#125; //第i个元素与最小元素进行交换 int temp = array[i]; array[i] = array[minIndex]; array[minIndex] = temp; &#125; &#125; //这个就是稳定算法了 public static void selectSort2(int array[]) &#123; int minIndex = 0; if ((array == null) || (array.length == 0)) return; for (int i = 0; i &lt; array.length; i++) &#123; minIndex = i;//无序区的最小数据数组下标 for (int j = i + 1; j &lt; array.length; j++) &#123;//在无序区中找到最小数据并保存其数组下标 if (array[j] &lt; array[minIndex]) &#123; minIndex = j; &#125; &#125; if (minIndex != i) &#123;//如果不是无序区的最小值位置且不是默认的第一个数据，则交换之。 //第i个元素与最小元素进行交换 int temp = array[i]; array[i] = array[minIndex]; array[minIndex] = temp; &#125; &#125; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/tags/数据结构/"}]},{"title":"插入排序","slug":"2015-01-02-插入排序","date":"2015-01-02T00:00:00.000Z","updated":"2018-01-19T04:00:02.914Z","comments":true,"path":"2015-01-02-插入排序/","link":"","permalink":"http://liuyiyou.cn/2015-01-02-插入排序/","excerpt":"","text":"概述插入排序包括 直接插入排序和希尔排序 直接插入排序的基本操作是：假设第一个元素是有序的，每次从无序表中取出第一个元素，把它插入到有序表的合适位置，从而得到一个新的，记录数增1的有序表 第一种方式： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素小于前面的元素（已排序），则依次与前面元素进行比较如果小于则交换，直到找到大于该元素的就则停止； 如果该元素大于前面的元素（已排序），则重复步骤2 重复步骤2~4 直到所有元素都排好序 。 第二种方式： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素小于前面的元素（已排序），则依次与前面元素进行比较如果小于则继续与前面的的数比较，直到找到大于该元素的就则停止； 将该位置后面的元素整体移动一位，再交换 重复步骤2~4 直到所有元素都排好序 。 两种方式，第一种是逐个交换，第二种是先找到，再整体后移，最后进行交换 动画演示:排序过程 具体步骤： ##算法原理 直接插入排序算法的运作如下 第一个元素默认有序，从第二个元素与它前面的元素进行比较 如果第二个元素比第一个元素小，则将该元素用临时变量来保存，并将他前面的元素进行后移 一直移动到比该元素小的位置，将元素插入到该位置 ##算法分析 ###时间复杂度 若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数$$C$$和记录移动次数$$M$$均达到最小值:$$C_{min}=n-1$$, $$M_{min}=0$$。所以，冒泡排序最好的时间复杂度为$$O(n) 。 若初始文件是反序的，需要进行$$n-1$$趟排序。每趟排序要进行$$n-i$$次关键字的比较($$1≤i≤n-1$$),且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值： $$C_{max} = \\left(n(n-1)\\over 2 \\right) = O(n^2)$$ $$M_{max} = \\frac{3n(n-1)}{2} = O(n^2)$$ 直接排序的最坏时间复杂度为$$O(n^2)$$ 。 综上，因此冒泡排序总的平均时间复杂度为$$O(n^2)$$ ，空间复杂度为$$O(1)$$ 算法稳定性冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。 算法描述package cn.liuyiyou.sort; /** * 插入排序：插入排序包括 直接插入排序和希尔排序 直接插入排序的基本操作是：将一个记录插入到已排好序的有序列表中，从而得到一个新的，记录数增1的有序表。 */ public class InsertSort &#123; //第一种：比前面的元素小的时候，先交换 public static void insertSort2(int[] array) &#123; for (int i = 1; i &lt; array.length; i++) &#123; // 从i个元素开始，依次与i之前的元素进行比较 for (int j = i; j &gt; 0; j--) &#123; if (array[j - 1] &gt; array[j]) &#123; int temp = array[j - 1]; array[j - 1] = array[j]; array[j] = temp; &#125; else &#123; //快速退出 break; &#125; &#125; &#125; &#125; //先后移，再交换 public static void insertSort3(int[] array) &#123; for (int i = 1; i &lt; array.length; i++) &#123; int temp = array[i]; //这个可以放在if里面 int j = i; if (array[i] &lt;array[i - 1] ) &#123; for ( ; j &gt; 0 &amp;&amp; temp &lt; array[j - 1] ; j--) &#123; array[j] = array[j - 1]; &#125; array[j] = temp; &#125; &#125; &#125; //while实现 public static void insertSort2(int[] array)&#123; //从位置1开始，0做为哨兵 for (int i = 1 ; i &lt; array.length; i++)&#123; //保存当前位置到临时变量 int temp = array[i]; //将当前位置赋给紧邻的未排序的起点 int j = i; //如果未排序的数小于已排序的树 if (array[i-1]&gt;array[i])&#123; //向后移动一个位置 while (j&gt;0 &amp;&amp; array[j-1]&gt; temp)&#123; //只能是temp，不能是array[i] ,如果是array[i],在执行下面这句话的时候，array[i]会改的值被改变了 array[j] = array[j-1]; j--; &#125; //将当前位置存放为i array[j] = temp; //同上，比如i为1的时候array[i]=3，array[j-1]为1，执行while里面的前移之后，array[j]=array[i]=3.而实际的情况应该是array[j] &#125; &#125; &#125; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/tags/数据结构/"}]},{"title":"冒泡排序","slug":"2015-01-01-冒泡排序","date":"2015-01-01T00:00:00.000Z","updated":"2018-01-23T06:00:46.040Z","comments":true,"path":"2015-01-01-冒泡排序/","link":"","permalink":"http://liuyiyou.cn/2015-01-01-冒泡排序/","excerpt":"","text":"概述冒泡排序：它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名 动画演示:排序过程 算法原理冒泡排序算法的运作如下：（从后往前） 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较 算法分析时间复杂度若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数$$C$$和记录移动次数$$M$$均达到最小值:$$C_{min}=n-1$$,$$M_{min}=0$$。所以，冒泡排序最好的时间复杂度为$$O(n)$$ 。 若初始文件是反序的，需要进行$$n-1$$趟排序。每趟排序要进行$$n-i$$次关键字的比较($$1≤i≤n-1$$),且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值： $$C_{max} = \\left(n(n-1)\\over 2 \\right) = O(n^2)$$ $$M_{max} = \\frac{3n(n-1)}{2} = O(n^2)$$ 冒泡排序的最坏时间复杂度为$$O(n^2)$$ 。 综上，因此冒泡排序总的平均时间复杂度为$$O(n^2)$$ 算法稳定性冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。 算法描述package cn.liuyiyou.sort;/** * 冒泡排序： * User: liuyiyou * Date: 13-1-1 * Time: 下午4:04 */public class BubbleSort &#123; /** * 这个是冒泡排序，冒泡排序是待排序的数和后面相邻的数比较大小 * 注意内层循环中j的取值变化，之前i的初始值是1，j的临界值是array.length。 * @param array */ public static void bubbleSort1(int[] array)&#123; for (int i=0;i&lt;array.length;i++)&#123; for (int j = 0; j&lt;array.length-i-1;j++ )&#123; if (array[j] &gt; array[j+1])&#123; SortUtil.swap(array,j,j+1); &#125; &#125; SortUtil.print(array, i); &#125; &#125; public static void bubbleSort2(int[] array)&#123; for (int i=0;i&lt;array.length;i++)&#123; for (int j = 0; j&lt; i;j++ )&#123; if (array[i]&lt;array[j])&#123; SortUtil.swap(array,i,j); &#125; &#125; SortUtil.print(array, i); &#125; &#125; public static void bubbleSort3(int[] array) &#123; for (int i = 0; i &lt; array.length - 1; i++) &#123; // 最多做n-1趟排序 // 对当前无序区间score[0......length-i-1]进行排序(j的范围很关键，这个范围是在逐步缩小的) for (int j = 0; j &lt; array.length - i - 1; j++) &#123; if (array[j] &lt; array[j + 1]) &#123; // 把小的值交换到后面 SortUtil.swap(array, j, j + 1); &#125; &#125; SortUtil.print(array, i); &#125; &#125; public static void main(String [] args)&#123; int [] array = SortUtil.array; System.out.println(\"原始排序结果：\"); SortUtil.print(array); bubbleSort3(array); System.out.println(\"最终排序结果：\"); SortUtil.print(array); &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/tags/数据结构/"}]}]}