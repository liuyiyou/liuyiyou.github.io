{"meta":{"title":"温故而知新    触类而旁通","subtitle":"In me the tiger Sniffs the rose","description":"温故而知新、触类而旁通","author":"liuyiyou","url":"http://liuyiyou.cn","root":"/"},"pages":[{"title":"关于我","date":"2015-10-26T14:37:55.000Z","updated":"2017-12-15T01:52:02.446Z","comments":true,"path":"about/index.html","permalink":"http://liuyiyou.cn/about/index.html","excerpt":"","text":"联系方式 Email：liuyiyou_cn@qq.com 二维码:"},{"title":"书单","date":"2019-04-03T06:01:05.865Z","updated":"2019-04-03T03:19:40.895Z","comments":false,"path":"books/index.html","permalink":"http://liuyiyou.cn/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2014-12-22T04:39:04.000Z","updated":"2017-04-14T03:25:16.000Z","comments":true,"path":"categories/index.html","permalink":"http://liuyiyou.cn/categories/index.html","excerpt":"","text":""},{"title":"收藏","date":"2015-10-26T14:37:55.000Z","updated":"2019-01-29T09:32:34.898Z","comments":true,"path":"inbox/index.html","permalink":"http://liuyiyou.cn/inbox/index.html","excerpt":"","text":"后台模板基于 Ant Design of Vue 实现的 Ant Design Pro Vue 版轮子 其他Spring资料大全 : 持续更新 OSX软件的安装 ：这个是我自己汇总的，包含很多常用软件或者工具的安装 自己总结的SpringBoot&amp;SpringCloud系列 深入剖析Spring Web源码 Git在线书籍 是一个完整的书籍 Java虚拟机详解 Java NIO Tiny-Spring ：这个对了解Spring源码比价有用 Mysql-Proxy ：可以解决本地无法连接线上数据库，转而通过代理来连接的问题 Elasticsearch权威指南 美团点评数据仓库开发模式演进 github明星项目 ：可以关注一下最热最火的项目 shiro官方教程 effecttive-java读书笔记"},{"title":"友链","date":"2019-04-04T01:37:40.163Z","updated":"2019-04-04T01:37:40.163Z","comments":false,"path":"links/index.html","permalink":"http://liuyiyou.cn/links/index.html","excerpt":"","text":"yiyouFun"},{"title":"标签","date":"2019-04-03T13:23:39.330Z","updated":"2019-04-03T03:19:40.897Z","comments":false,"path":"tags/index.html","permalink":"http://liuyiyou.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java8新特性-Optional","slug":"Java8新特性-Optional","date":"2018-03-12T16:00:00.000Z","updated":"2019-04-23T08:48:18.461Z","comments":true,"path":"Java8新特性-Optional/","link":"","permalink":"http://liuyiyou.cn/Java8新特性-Optional/","excerpt":"","text":"作用减少NPE","categories":[{"name":"java","slug":"java","permalink":"http://liuyiyou.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://liuyiyou.cn/tags/java/"}]},{"title":"Java8新特性","slug":"2018-03-14-Java8新特性","date":"2018-03-12T16:00:00.000Z","updated":"2018-05-04T08:14:35.590Z","comments":true,"path":"2018-03-14-Java8新特性/","link":"","permalink":"http://liuyiyou.cn/2018-03-14-Java8新特性/","excerpt":"","text":"关于本文介绍了Java SE 8中新引入的lambda语言特性以及这些特性背后的设计思想。这些特性包括： （在百度上搜上面这段话，可以看到原文） lambda表达式（又被成为“闭包”或“匿名方法”） 方法引用和构造方法引用 扩展的目标类型和类型推导 接口中的默认方法和静态方法 背景Java是一门面向对象编程语言。面向对象编程语言和函数式编程语言中的基本元素（Basic Values）都可以动态封装程序行为：面向对象编程语言使用带有方法的对象封装行为，函数式编程语言使用函数封装行为。但这个相同点并不明显，因为Java的对象往往比较“重量级”：实例化一个类型往往会涉及不同的类，并需要初始化类里的字段和方法。不过有些Java对象只是对单个函数的封装。例如下面这个典型用例：Java API中定义了一个接口（一般被称为回调接口），用户通过提供这个接口的实例来传入指定行为，例如： public interface ActionListener &#123; void actionPerformed(ActionEvent e);&#125; 这里并不需要专门定义一个类来实现ActionListener接口，因为它只会在调用处被使用一次。用户一般会使用匿名类型把行为内联（inline）： button.addActionListener(new ActionListener) &#123; public void actionPerformed(ActionEvent e) &#123; ui.dazzle(e.getModifiers()); &#125;&#125; 很多库都依赖于上面的模式。对于并行API更是如此，因为我们需要把待执行的代码提供给并行API，并行编程是一个非常值得研究的领域，因为在这里摩尔定律得到了重生：尽管我们没有更快的CPU核心（core），但是我们有更多的CPU核心。而串行API就只能使用有限的计算能力。随着回调模式和函数式编程风格的日益流行，我们需要在Java中提供一种尽可能轻量级的将代码封装为数据（Model code as data）的方法。 匿名内部类并不是一个好的选择，因为： 语法过于冗余 匿名类中的this和变量名容易使人产生误解 类型载入和实例创建语义不够灵活 无法捕获非final的局部变量 无法对控制流进行抽象 上面的多数问题均在Java SE 8中得以解决： · 通过提供更简洁的语法和局部作用域规则，Java SE 8彻底解决了问题1和问题2· 通过提供更加灵活而且便于优化的表达式语义，Java SE 8绕开了问题3· 通过允许编译器推断变量的“常量性”（finality），Java SE 8减轻了问题4带来的困扰不过，Java SE 8的目标并非解决所有上述问题。因此捕获可变变量（问题4）和非局部控制流（问题5）并不在Java SE 8的范畴之内。（尽管我们可能会在未来提供对这些特性的支持） 函数式接口（Functional interfaces）尽管匿名内部类有着种种限制和问题，但是它有一个良好的特性，它和Java类型系统结合的十分紧密：每一个函数对象都对应一个接口类型。之所以说这个特性是良好的，是因为： 接口是Java类型系统的一部分 接口天然就拥有其运行时表示（Runtime representation） 接口可以通过Javadoc注释来表达一些非正式的协定（contract），例如，通过注释说明该操作应可交换（commutative）上面提到的ActionListener接口只有一个方法，大多数回调接口都拥有这个特征：比如Runnable接口和Comparator接口。我们把这些只拥有一个方法的接口称为函数式接口。（之前它们被称为SAM类型，即单抽象方法类型（Single Abstract Method）） 我们并不需要额外的工作来声明一个接口是函数式接口：编译器会根据接口的结构自行判断（判断过程并非简单的对接口方法计数：一个接口可能冗余的定义了一个Object已经提供的方法，比如toString()，或者定义了静态方法或默认方法，这些都不属于函数式接口方法的范畴）。不过API作者们可以通过@FunctionalInterface注解来显式指定一个接口是函数式接口（以避免无意声明了一个符合函数式标准的接口），加上这个注解之后，编译器就会验证该接口是否满足函数式接口的要求。实现函数式类型的另一种方式是引入一个全新的结构化函数类型，我们也称其为“箭头”类型。例如，一个接收String和Object并返回int的函数类型可以被表示为(String, Object) -&gt; int。我们仔细考虑了这个方式，但出于下面的原因，最终将其否定： 它会为Java类型系统引入额外的复杂度，并带来结构类型（Structural Type）和指名类型（Nominal Type）的混用。（Java几乎全部使用指名类型） 它会导致类库风格的分歧——一些类库会继续使用回调接口，而另一些类库会使用结构化函数类型 它的语法会变得十分笨拙，尤其在包含受检异常（checked exception）之后 每个函数类型很难拥有其运行时表示，这意味着开发者会受到类型擦除（erasure）的困扰和局限。比如说，我们无法对方法m(T-&gt;U)和m(X-&gt;Y)进行重载（Overload） 所以我们选择了“使用已知类型”这条路——因为现有的类库大量使用了函数式接口，通过沿用这种模式，我们使得现有类库能够直接使用lambda表达式。例如下面是Java SE 7中已经存在的函数式接口： java.lang.Runnable java.util.concurrent.Callable java.security.PrivilegedAction java.util.Comparator java.io.FileFilter java.beans.PropertyChangeListener 除此之外，Java SE 8中增加了一个新的包：java.util.function，它里面包含了常用的函数式接口，例如： Predicate——接收T对象并返回boolean Consumer——接收T对象，不返回值 Function&lt;T, R&gt;——接收T对象，返回R对象 Supplier——提供T对象（例如工厂），不接收值 UnaryOperator——接收T对象，返回T对象 BinaryOperator——接收两个T对象，返回T对象 除了上面的这些基本的函数式接口，我们还提供了一些针对原始类型（Primitive type）的特化（Specialization）函数式接口，例如IntSupplier和LongBinaryOperator。（我们只为int、long和double提供了特化函数式接口，如果需要使用其它原始类型则需要进行类型转换）同样的我们也提供了一些针对多个参数的函数式接口，例如BiFunction&lt;T, U, R&gt;，它接收T对象和U对象，返回R对象。 lambda表达式（lambda expressions）匿名类型最大的问题就在于其冗余的语法。有人戏称匿名类型导致了“高度问题”（height problem）：比如前面ActionListener的例子里的五行代码中仅有一行在做实际工作。lambda表达式是匿名方法，它提供了轻量级的语法，从而解决了匿名内部类带来的“高度问题”。下面是一些lambda表达式： (int x, int y) -&gt; x + y() -&gt; 42(String s) -&gt; &#123; System.out.println(s); &#125; 第一个lambda表达式接收x和y这两个整形参数并返回它们的和；第二个lambda表达式不接收参数，返回整数’42’；第三个lambda表达式接收一个字符串并把它打印到控制台，不返回值。 lambda表达式的语法由参数列表、箭头符号-&gt;和函数体组成。函数体既可以是一个表达式，也可以是一个语句块：· 表达式：表达式会被执行然后返回执行结果。· 语句块：语句块中的语句会被依次执行，就像方法中的语句一样—— return语句会把控制权交给匿名方法的调用者 break和continue只能在循环中使用 如果函数体有返回值，那么函数体内部的每一条路径都必须返回值表达式函数体适合小型lambda表达式，它消除了return关键字，使得语法更加简洁。lambda表达式也会经常出现在嵌套环境中，比如说作为方法的参数。为了使lambda表达式在这些场景下尽可能简洁，我们去除了不必要的分隔符。不过在某些情况下我们也可以把它分为多行，然后用括号包起来，就像其它普通表达式一样。下面是一些出现在语句中的lambda表达式： FileFilter java = (File f) -&gt; f.getName().endsWith(\"*.java\");String user = doPrivileged(() -&gt; System.getProperty(\"user.name\"));new Thread(() -&gt; &#123; connectToService(); sendNotification();&#125;).start(); 目标类型（Target typing）需要注意的是，函数式接口的名称并不是lambda表达式的一部分。那么问题来了，对于给定的lambda表达式，它的类型是什么？答案是：它的类型是由其上下文推导而来。例如，下面代码中的lambda表达式类型是ActionListener：ActionListener l = (ActionEvent e) -&gt; ui.dazzle(e.getModifiers());这就意味着同样的lambda表达式在不同上下文里可以拥有不同的类型： Callable&lt;String&gt; c = () -&gt; \"done\"; PrivilegedAction&lt;String&gt; a = () -&gt; \"done\"; 第一个lambda表达式() -&gt; “done”是Callable的实例，而第二个lambda表达式则是PrivilegedAction的实例。编译器负责推导lambda表达式的类型。它利用lambda表达式所在上下文所期待的类型进行推导，这个被期待的类型被称为目标类型。lambda表达式只能出现在目标类型为函数式接口的上下文中。当然，lambda表达式对目标类型也是有要求的。编译器会检查lambda表达式的类型和目标类型的方法签名（method signature）是否一致。当且仅当下面所有条件均满足时，lambda表达式才可以被赋给目标类型T： T是一个函数式接口 lambda表达式的参数和T的方法参数在数量和类型上一一对应 lambda表达式的返回值和T的方法返回值相兼容（Compatible） lambda表达式内所抛出的异常和T的方法throws类型相兼容 由于目标类型（函数式接口）已经“知道”lambda表达式的形式参数（Formal parameter）类型，所以我们没有必要把已知类型再重复一遍。也就是说，lambda表达式的参数类型可以从目标类型中得出： Comparator&lt;String&gt; c = (s1, s2) -&gt; s1.compareToIgnoreCase(s2); 在上面的例子里，编译器可以推导出s1和s2的类型是String。此外，当lambda的参数只有一个而且它的类型可以被推导得知时，该参数列表外面的括号可以被省略： FileFilter java = f -&gt; f.getName().endsWith(\".java\");button.addActionListener(e -&gt; ui.dazzle(e.getModifiers())); 这些改进进一步展示了我们的设计目标：“不要把高度问题转化成宽度问题。”我们希望语法元素能够尽可能的少，以便代码的读者能够直达lambda表达式的核心部分。lambda表达式并不是第一个拥有上下文相关类型的Java表达式：泛型方法调用和“菱形”构造器调用也通过目标类型来进行类型推导： List&lt;String&gt; ls = Collections.emptyList();List&lt;Integer&gt; li = Collections.emptyList(); Map&lt;String, Integer&gt; m1 = new HashMap&lt;&gt;();Map&lt;Integer, String&gt; m2 = new HashMap&lt;&gt;(); 目标类型的上下文（Contexts for target typing）之前我们提到lambda表达式智能出现在拥有目标类型的上下文中。下面给出了这些带有目标类型的上下文： 变量声明 赋值 返回语句 数组初始化器 方法和构造方法的参数 lambda表达式函数体 条件表达式（? :） 转型（Cast）表达式 在前三个上下文（变量声明、赋值和返回语句）里，目标类型即是被赋值或被返回的类型： Comparator&lt;String&gt; c;c = (String s1, String s2) -&gt; s1.compareToIgnoreCase(s2); public Runnable toDoLater() &#123; return () -&gt; &#123; System.out.println(\"later\"); &#125;&#125; 数组初始化器和赋值类似，只是这里的“变量”变成了数组元素，而类型是从数组类型中推导得知： filterFiles(new FileFilter[] &#123; f -&gt; f.exists(), f -&gt; f.canRead(), f -&gt; f.getName().startsWith(\"q\") &#125;); 方法参数的类型推导要相对复杂些：目标类型的确认会涉及到其它两个语言特性：重载解析（Overload resolution）和参数类型推导（Type argument inference）。 重载解析会为一个给定的方法调用（method invocation）寻找最合适的方法声明（method declaration）。由于不同的声明具有不同的签名，当lambda表达式作为方法参数时，重载解析就会影响到lambda表达式的目标类型。编译器会通过它所得之的信息来做出决定。如果lambda表达式具有显式类型（参数类型被显式指定），编译器就可以直接 使用lambda表达式的返回类型；如果lambda表达式具有隐式类型（参数类型被推导而知），重载解析则会忽略lambda表达式函数体而只依赖lambda表达式参数的数量。如果在解析方法声明时存在二义性（ambiguous），我们就需要利用转型（cast）或显式lambda表达式来提供更多的类型信息。如果lambda表达式的返回类型依赖于其参数的类型，那么lambda表达式函数体有可能可以给编译器提供额外的信息，以便其推导参数类型。 List&lt;Person&gt; ps = ...Stream&lt;String&gt; names = ps.stream().map(p -&gt; p.getName()); 在上面的代码中，ps的类型是List，所以ps.stream()的返回类型是Stream。map()方法接收一个类型为Function&lt;T, R&gt;的函数式接口，这里T的类型即是Stream元素的类型，也就是Person，而R的类型未知。由于在重载解析之后lambda表达式的目标类型仍然未知，我们就需要推导R的类型：通过对lambda表达式函数体进行类型检查，我们发现函数体返回String，因此R的类型是String，因而map()返回Stream。绝大多数情况下编译器都能解析出正确的类型，但如果碰到无法解析的情况，我们则需要： 使用显式lambda表达式（为参数p提供显式类型）以提供额外的类型信息 把lambda表达式转型为Function&lt;Person, String&gt; 为泛型参数R提供一个实际类型。（.map(p -&gt; p.getName())） lambda表达式本身也可以为它自己的函数体提供目标类型，也就是说lambda表达式可以通过外部目标类型推导出其内部的返回类型，这意味着我们可以方便的编写一个返回函数的函数： Supplier&lt;Runnable&gt; c = () -&gt; () -&gt; &#123; System.out.println(\"hi\"); &#125;; 类似的，条件表达式可以把目标类型“分发”给其子表达式： Callable&lt;Integer&gt; c = flag ? (() -&gt; 23) : (() -&gt; 42); 最后，转型表达式（Cast expression）可以显式提供lambda表达式的类型，这个特性在无法确认目标类型时非常有用： // Object o = () -&gt; &#123; System.out.println(\"hi\"); &#125;; 这段代码是非法的Object o = (Runnable) () -&gt; &#123; System.out.println(\"hi\"); &#125;; 除此之外，当重载的方法都拥有函数式接口时，转型可以帮助解决重载解析时出现的二义性。目标类型这个概念不仅仅适用于lambda表达式，泛型方法调用和“菱形”构造方法调用也可以从目标类型中受益，下面的代码在Java SE 7是非法的，C List&lt;String&gt; ls = Collections.checkedList(new ArrayList&lt;&gt;(), String.class); Set&lt;Integer&gt; si = flag ? Collections.singleton(23) : Collections.emptySet(); 词法作用域（Lexical scoping）在内部类中使用变量名（以及this）非常容易出错。内部类中通过继承得到的成员（包括来自Object的方法）可能会把外部类的成员掩盖（shadow），此外未限定（unqualified）的this引用会指向内部类自己而非外部类。相对于内部类，lambda表达式的语义就十分简单：它不会从超类（supertype）中继承任何变量名，也不会引入一个新的作用域。lambda表达式基于词法作用域，也就是说lambda表达式函数体里面的变量和它外部环境的变量具有相同的语义（也包括lambda表达式的形式参数）。此外，’this’关键字及其引用在lambda表达式内部和外部也拥有相同的语义。为了进一步说明词法作用域的优点，请参考下面的代码，它会把”Hello, world!”打印两遍： public class Hello &#123; Runnable r1 = () -&gt; &#123; System.out.println(this); &#125; Runnable r2 = () -&gt; &#123; System.out.println(toString()); &#125; public String toString() &#123; return \"Hello, world\"; &#125; public static void main(String... args) &#123; new Hello().r1.run(); new Hello().r2.run(); &#125;&#125; 与之相类似的内部类实现则会打印出类似Hello$1@5b89a773和Hello$2@537a7706之类的字符串，这往往会使开发者大吃一惊。基于词法作用域的理念，lambda表达式不可以掩盖任何其所在上下文中的局部变量，它的行为和那些拥有参数的控制流结构（例如for循环和catch从句）一致。个人补充：这个说法很拗口，所以我在这里加一个例子以演示词法作用域： int i = 0;int sum = 0;for (int i = 1; i &lt; 10; i += 1) &#123; //这里会出现编译错误，因为i已经在for循环外部声明过了 sum += i;&#125; 变量捕获（Variable capture）在Java SE 7中，编译器对内部类中引用的外部变量（即捕获的变量）要求非常严格：如果捕获的变量没有被声明为final就会产生一个编译错误。我们现在放宽了这个限制——对于lambda表达式和内部类，我们允许在其中捕获那些符合有效只读（Effectively final）的局部变量。简单的说，如果一个局部变量在初始化后从未被修改过，那么它就符合有效只读的要求，换句话说，加上final后也不会导致编译错误的局部变量就是有效只读变量。 Callable&lt;String&gt; helloCallable(String name) &#123; String hello = \"Hello\"; return () -&gt; (hello + \", \" + name);&#125; 对this的引用，以及通过this对未限定字段的引用和未限定方法的调用在本质上都属于使用final局部变量。包含此类引用的lambda表达式相当于捕获了this实例。在其它情况下，lambda对象不会保留任何对this的引用。这个特性对内存管理是一件好事：内部类实例会一直保留一个对其外部类实例的强引用，而那些没有捕获外部类成员的lambda表达式则不会保留对外部类实例的引用。要知道内部类的这个特性往往会造成内存泄露。尽管我们放宽了对捕获变量的语法限制，但试图修改捕获变量的行为仍然会被禁止，比如下面这个例子就是非法的： int sum = 0;list.forEach(e -&gt; &#123; sum += e.size(); &#125;); 为什么要禁止这种行为呢？因为这样的lambda表达式很容易引起race condition。除非我们能够强制（最好是在编译时）这样的函数不能离开其当前线程，但如果这么做了可能会导致更多的问题。简而言之，lambda表达式对值封闭，对变量开放。个人补充：lambda表达式对值封闭，对变量开放的原文是：lambda expressions close overvalues, not variables，我在这里增加一个例子以说明这个特性： int sum = 0;list.forEach(e -&gt; &#123; sum += e.size(); &#125;); // Illegal, close over valuesList&lt;Integer&gt; aList = new List&lt;&gt;();list.forEach(e -&gt; &#123; aList.add(e); &#125;); // Legal, open over variables lambda表达式不支持修改捕获变量的另一个原因是我们可以使用更好的方式来实现同样的效果：使用规约（reduction）。java.util.stream包提供了各种通用的和专用的规约操作（例如sum、min和max），就上面的例子而言，我们可以使用规约操作（在串行和并行下都是安全的）来代替forEach：int sum = list.stream() .mapToInt(e -&gt; e.size()) .sum(); sum()等价于下面的规约操作： int sum = list.stream() .mapToInt(e -&gt; e.size()) .reduce(0 , (x, y) -&gt; x + y); 规约需要一个初始值（以防输入为空）和一个操作符（在这里是加号），然后用下面的表达式计算结果：1 0 + list[0] + list[1] + list[2] + …规约也可以完成其它操作，比如求最小值、最大值和乘积等等。如果操作符具有可结合性（associative），那么规约操作就可以容易的被并行化。所以，与其支持一个本质上是并行而且容易导致race condition的操作，我们选择在库中提供一个更加并行友好且不容易出错的方式来进行累积（accumulation）。 8. 方法引用（Method references）lambda表达式允许我们定义一个匿名方法，并允许我们以函数式接口的方式使用它。我们也希望能够在已有的方法上实现同样的特性。方法引用和lambda表达式拥有相同的特性（例如，它们都需要一个目标类型，并需要被转化为函数式接口的实例），不过我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有方法。以下面的代码为例，假设我们要按照name或age为Person数组进行排序： class Person &#123; private final String name; private final int age; public int getAge() &#123; return age; &#125; public String getName() &#123;return name; &#125; ...&#125; Person[] people = ...Comparator&lt;Person&gt; byName = Comparator.comparing(p -&gt; p.getName());Arrays.sort(people, byName); 在这里我们可以用方法引用代替lambda表达式： Comparator&lt;Person&gt; byName = Comparator.comparing(Person::getName); 这里的Person::getName可以被看作为lambda表达式的简写形式。尽管方法引用不一定（比如在这个例子里）会把语法变的更紧凑，但它拥有更明确的语义——如果我们想要调用的方法拥有一个名字，我们就可以通过它的名字直接调用它。因为函数式接口的方法参数对应于隐式方法调用时的参数，所以被引用方法签名可以通过放宽类型，装箱以及组织到参数数组中的方式对其参数进行操作，就像在调用实际方法一样： Consumer&lt;Integer&gt; b1 = System::exit; // void exit(int status)Consumer&lt;String[]&gt; b2 = Arrays:sort; // void sort(Object[] a)Consumer&lt;String&gt; b3 = MyProgram::main; // void main(String... args)Runnable r = Myprogram::mapToInt // void main(String... args) 方法引用的种类（Kinds of method references）方法引用有很多种，它们的语法如下：· 静态方法引用：ClassName::methodName· 实例上的实例方法引用：instanceReference::methodName· 超类上的实例方法引用：super::methodName· 类型上的实例方法引用：ClassName::methodName· 构造方法引用：Class::new· 数组构造方法引用：TypeName[]::new对于静态方法引用，我们需要在类名和方法名之间加入::分隔符，例如Integer::sum。对于具体对象上的实例方法引用，我们则需要在对象名和方法名之间加入分隔符： Set&lt;String&gt; knownNames = ...Predicate&lt;String&gt; isKnown = knownNames::contains; 这里的隐式lambda表达式（也就是实例方法引用）会从knownNames中捕获String对象，而它的方法体则会通过Set.contains使用该String对象。有了实例方法引用，在不同函数式接口之间进行类型转换就变的很方便： Callable&lt;Path&gt; c = ...Privileged&lt;Path&gt; a = c::call; 引用任意对象的实例方法则需要在实例方法名称和其所属类型名称间加上分隔符：1 Function&lt;String, String&gt; upperfier = String::toUpperCase;这里的隐式lambda表达式（即String::toUpperCase实例方法引用）有一个String参数，这个参数会被toUpperCase方法使用。如果类型的实例方法是泛型的，那么我们就需要在::分隔符前提供类型参数，或者（多数情况下）利用目标类型推导出其类型。需要注意的是，静态方法引用和类型上的实例方法引用拥有一样的语法。编译器会根据实际情况做出决定。一般我们不需要指定方法引用中的参数类型，因为编译器往往可以推导出结果，但如果需要我们也可以显式在::分隔符之前提供参数类型信息。和静态方法引用类似，构造方法也可以通过new关键字被直接引用： SocketImplFactory factory = MySocketImpl::new; 如果类型拥有多个构造方法，那么我们就会通过目标类型的方法参数来选择最佳匹配，这里的选择过程和调用构造方法时的选择过程是一样的。如果待实例化的类型是泛型的，那么我们可以在类型名称之后提供类型参数，否则编译器则会依照”菱形”构造方法调用时的方式进行推导。数组的构造方法引用的语法则比较特殊，为了便于理解，你可以假想存在一个接收int参数的数组构造方法。参考下面的代码： IntFunction&lt;int[]&gt; arrayMaker = int[]::new;int[] array = arrayMaker.apply(10) // 创建数组 int[10] 10. 默认方法和静态接口方法（Default and static interface methods）lambda表达式和方法引用大大提升了Java的表达能力（expressiveness），不过为了使把代码即数据（code-as-data）变的更加容易，我们需要把这些特性融入到已有的库之中，以便开发者使用。 Java SE 7时代为一个已有的类库增加功能是非常困难的。具体的说，接口在发布之后就已经被定型，除非我们能够一次性更新所有该接口的实现，否则向接口添加方法就会破坏现有的接口实现。默认方法（之前被称为虚拟扩展方法或守护方法）的目标即是解决这个问题，使得接口在发布之后仍能被逐步演化。这里给出一个例子，我们需要在标准集合API中增加针对lambda的方法。例如removeAll方法应该被泛化为接收一个函数式接口Predicate，但这个新的方法应该被放在哪里呢？我们无法直接在Collection接口上新增方法——不然就会破坏现有的Collection实现。我们倒是可以在Collections工具类中增加对应的静态方法，但这样就会把这个方法置于“二等公民”的境地。 默认方法利用面向对象的方式向接口增加新的行为。它是一种新的方法：接口方法可以是抽象的或是默认的。默认方法拥有其默认实现，实现接口的类型通过继承得到该默认实现（如果类型没有覆盖该默认实现）。此外，默认方法不是抽象方法，所以我们可以放心的向函数式接口里增加默认方法，而不用担心函数式接口的单抽象方法限制。下面的例子展示了如何向Iterator接口增加默认方法skip： interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); void remove(); default void skip(int i) &#123; for ( ; i &gt; 0 &amp;&amp; hasNext(); i -= 1) next(); &#125;&#125; 根据上面的Iterator定义，所有实现Iterator的类型都会自动继承skip方法。在使用者的眼里，skip不过是接口新增的一个虚拟方法。在没有覆盖skip方法的Iterator子类实例上调用skip会执行skip的默认实现：调用hasNext和next若干次。子类可以通过覆盖skip来提供更好的实现——比如直接移动游标（cursor），或是提供为操作提供原子性（Atomicity）等。当接口继承其它接口时，我们既可以为它所继承而来的抽象方法提供一个默认实现，也可以为它继承而来的默认方法提供一个新的实现，还可以把它继承而来的默认方法重新抽象化。除了默认方法，Java SE 8还在允许在接口中定义静态方法。这使得我们可以从接口直接调用和它相关的辅助方法（Helper method），而不是从其它的类中调用（之前这样的类往往以对应接口的复数命名，例如Collections）。比如，我们一般需要使用静态辅助方法生成实现Comparator的比较器，在Java SE 8中我们可以直接把该静态方法定义在Comparator接口中：public static &lt;T, U extends Comparable&lt;? super U&gt;&gt; Comparator&lt;T&gt; comparing(Function&lt;T, U&gt; keyExtractor) &#123; return (c1, c2) -&gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));&#125; 继承默认方法（Inheritance of default methods）和其它方法一样，默认方法也可以被继承，大多数情况下这种继承行为和我们所期待的一致。不过，当类型或者接口的超类拥有多个具有相同签名的方法时，我们就需要一套规则来解决这个冲突：· 类的方法（class method）声明优先于接口默认方法。无论该方法是具体的还是抽象的。· 被其它类型所覆盖的方法会被忽略。这条规则适用于超类型共享一个公共祖先的情况。为了演示第二条规则，我们假设Collection和List接口均提供了removeAll的默认实现，然后Queue继承并覆盖了Collection中的默认方法。在下面的implement从句中，List中的方法声明会优先于Queue中的方法声明：1 class LinkedList implements List, Queue { … }当两个独立的默认方法相冲突或是默认方法和抽象方法相冲突时会产生编译错误。这时程序员需要显式覆盖超类方法。一般来说我们会定义一个默认方法，然后在其中显式选择超类方法： interface Robot implements Artist, Gun &#123; default void draw() &#123; Artist.super.draw(); &#125;&#125; super前面的类型必须是有定义或继承默认方法的类型。这种方法调用并不只限于消除命名冲突——我们也可以在其它场景中使用它。最后，接口在inherits和extends从句中的声明顺序和它们被实现的顺序无关。 融会贯通（Putting it together）我们在设计lambda时的一个重要目标就是新增的语言特性和库特性能够无缝结合（designed to work together）。接下来，我们通过一个实际例子（按照姓对名字列表进行排序）来演示这一点：比如说下面的代码： List&lt;Person&gt; people = ...Collections.sort(people, new Comparator&lt;Person&gt;() &#123; public int compare(Person x, Person y) &#123; return x.getLastName().compareTo(y.getLastName()); &#125;&#125;) 冗余代码实在太多了！有了lambda表达式，我们可以去掉冗余的匿名类： Collections.sort(people,Person x, Person y) -&gt; x.getLastName().compareTo(y.getLastName())); 尽管代码简洁了很多，但它的抽象程度依然很差：开发者仍然需要进行实际的比较操作（而且如果比较的值是原始类型那么情况会更糟），所以我们要借助Comparator里的comparing方法实现比较操作： Collections.sort(people, Comparator.comparing((Person p) -&gt; p.getLastName())); 在类型推导和静态导入的帮助下，我们可以进一步简化上面的代码： Collections.sort(people, comparing(p -&gt; p.getLastName())); 我们注意到这里的lambda表达式实际上是getLastName的代理（forwarder），于是我们可以用方法引用代替它： Collections.sort(people, comparing(Person::getLastName)); 最后，使用Collections.sort这样的辅助方法并不是一个好主意：它不但使代码变的冗余，也无法为实现List接口的数据结构提供特定（specialized）的高效实现，而且由于Collections.sort方法不属于List接口，用户在阅读List接口的文档时不会察觉在另外的Collections类中还有一个针对List接口的排序（sort()）方法。默认方法可以有效的解决这个问题，我们为List增加默认方法sort()，然后就可以这样调用： people.sort(comparing(Person::getLastName));; 此外，如果我们为Comparator接口增加一个默认方法reversed()（产生一个逆序比较器），我们就可以非常容易的在前面代码的基础上实现降序排序。1 people.sort(comparing(Person::getLastName).reversed());; 小结（Summary） Java SE 8提供的新语言特性并不算多——lambda表达式，方法引用，默认方法和静态接口方法，以及范围更广的类型推导。但是把它们结合在一起之后，开发者可以编写出更加清晰简洁的代码，类库编写者可以编写更加强大易用的并行类库。 未完待续——本文是深入理解Java 8 Lambda系列的第二篇，主要介绍Java 8针对新增语言特性而新增的类库（例如Streams API、Collectors和并行）。本文是对Brian Goetz的State of the Lambda: Libraries Edition一文的翻译。Java SE 8增加了新的语言特性（例如lambda表达式和默认方法），为此Java SE 8的类库也进行了很多改进，本文简要介绍了这些改进。在阅读本文前，你应该先阅读深入浅出Java","categories":[{"name":"java","slug":"java","permalink":"http://liuyiyou.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://liuyiyou.cn/tags/java/"}]},{"title":"Java8新特性-Lambda","slug":"Java8新特性-Lambda","date":"2018-03-12T16:00:00.000Z","updated":"2018-05-04T08:13:05.539Z","comments":true,"path":"Java8新特性-Lambda/","link":"","permalink":"http://liuyiyou.cn/Java8新特性-Lambda/","excerpt":"","text":"背景（Background）自从lambda表达式成为Java语言的一部分之后，Java集合（Collections）API就面临着大幅变化。而JSR 355（规定了Java lambda表达式的标准）的正式启用更是使得Java集合API变的过时不堪。尽管我们可以从头实现一个新的集合框架（比如“Collection II”），但取代现有的集合框架是一项非常艰难的工作，因为集合接口渗透了Java生态系统的每个角落，将它们一一换成新类库需要相当长的时间。因此，我们决定采取演化的策略（而非推倒重来）以改进集合API： 为现有的接口（例如Collection，List和Stream）增加扩展方法； 在类库中增加新的流（stream，即java.util.stream.Stream）抽象以便进行聚集（aggregation）操作； 改造现有的类型使之可以提供流视图（stream view）； 改造现有的类型使之可以容易的使用新的编程模式，这样用户就不必抛弃使用以久的类库，例如ArrayList和HashMap（当然这并不是说集合API会常驻永存，毕竟集合API在设计之初 并没有考虑到lambda表达式。我们可能会在未来的JDK中添加一个更现代的集合类库）。除了上面的改进，还有一项重要工作就是提供更加易用的并行（Parallelism）库。尽管Java平台已经对并行和并发提供了强有力的支持，然而开发者在实际工作（将串行代码并行化）中仍然会碰到很多问题。因此，我们希望Java类库能够既便于编写串行代码也便于编写并行代码，因此我们把编程的重点从具体执行细节（how computation should be formed）转移到抽象执行步骤（what computation should be perfomed）。 除此之外，我们还需要在将并行变的容易（easier）和将并行变的不可见（invisible）之间做出抉择，我们选择了一个折中的路线：提供显式（explicit）但非侵入（unobstrusive）的并行。（如果把并行变的透明，那么很可能会引入不确定性（nondeterminism）以及各种数据竞争（data race）问题） 内部迭代和外部迭代（Internal vs external iteration）集合类库主要依赖于外部迭代（externaliteration）。Collection实现Iterable接口，从而使得用户可以依次遍历集合的元素。比如我们需要把一个集合中的形状都设置成红色，那么可以这么写： for (Shape shape : shapes) &#123; shape.setColor(RED);&#125; 这个例子演示了外部迭代：for-each循环调用shapes的iterator()方法进行依次遍历。外部循环的代码非常直接，但它有如下问题： Java的for循环是串行的，而且必须按照集合中元素的顺序进行依次处理； 集合框架无法对控制流进行优化，例如通过排序、并行、短路（short-circuiting）求值以及惰性求值改善性能。 尽管有时for-each循环的这些特性（串行，依次）是我们所期待的，但它对改善性能造成了阻碍。我们可以使用内部迭代（internal iteration）替代外部迭代，用户把对迭代的控制权交给类库，并向类库传递迭代时所需执行的代码。 下面是前例的内部迭代代码： shapes.forEach(s -&gt; s.setColor(RED)); 尽管看起来只是一个小小的语法改动，但是它们的实际差别非常巨大。用户把对操作的控制权交还给类库，从而允许类库进行各种各样的优化（例如乱序执行、惰性求值和并行等等）。总的来说，内部迭代使得外部迭代中不可能实现的优化成为可能。 外部迭代同时承担了做什么（把形状设为红色）和怎么做（得到Iterator实例然后依次遍历）两项职责，而内部迭代只负责做什么，而把怎么做留给类库。通过这样的职责转变：用户的代码会变得更加清晰，而类库则可以进行各种优化，从而使所有用户都从中受益。 流（Stream）流是Java SE 8类库中新增的关键抽象，它被定义于java.util.stream（这个包里有若干流类型：Stream代表对象引用流，此外还有一系列特化（specialization）流，比如IntStream代表整形数字流）。每个流代表一个值序列，流提供一系列常用的聚集操作，使得我们可以便捷的在它上面进行各种运算。集合类库也提供了便捷的方式使我们可以以操作流的方式使用集合、数组以及其它数据结构。流的操作可以被组合成流水线（Pipeline）。以前面的例子为例，如果我们只想把蓝色改成红色： shapes.stream() .filter(s -&gt; s.getColor() == BLUE) .forEach(s -&gt; s.setColor(RED)); 在Collection上调用stream()会生成该集合元素的流视图（stream view），接下来filter()操作会产生只包含蓝色形状的流，最后，这些蓝色形状会被forEach操作设为红色。如果我们想把蓝色的形状提取到新的List里，则可以： List&lt;Shape&gt; blue = shapes.stream() .filter(s -&gt; s.getColor() == BLUE) .collect(Collectors.toList()); collect()操作会把其接收的元素聚集（aggregate）到一起（这里是List），collect()方法的参数则被用来指定如何进行聚集操作。在这里我们使用toList()以把元素输出到List中。（如需更多collect()方法的细节，请阅读Collectors一节）如果每个形状都被保存在Box里，然后我们想知道哪个盒子至少包含一个蓝色形状，我们可以这么写： Set&lt;Box&gt; hasBlueShape = shapes.stream() .filter(s -&gt; s.getColor() == BLUE) .map(s -&gt; s.getContainingBox()) .collect(Collectors.toSet()); map()操作通过映射函数（这里的映射函数接收一个形状，然后返回包含它的盒子）对输入流里面的元素进行依次转换，然后产生新流。 如果我们需要得到蓝色物体的总重量，我们可以这样表达： int sum = shapes.stream() .filter(s -&gt; s.getColor() == BLUE) .mapToInt(s -&gt; s.getWeight()) .sum(); 这些例子演示了流框架的设计，以及如何使用流框架解决实际问题。 流和集合（Streams vs Collections）集合和流尽管在表面上看起来很相似，但它们的设计目标是不同的：集合主要用来对其元素进行有效（effective）的管理和访问（access），而流并不支持对其元素进行直接操作或直接访问，而只支持通过声明式操作在其上进行运算然后得到结果。除此之外，流和集合还有一些其它不同： 无存储：流并不存储值；流的元素源自数据源（可能是某个数据结构、生成函数或I/O通道等等），通过一系列计算步骤得到； 天然的函数式风格（Functional in nature）：对流的操作会产生一个结果，但流的数据源不会被修改； 惰性求值：多数流操作（包括过滤、映射、排序以及去重）都可以以惰性方式实现。这使得我们可以用一遍遍历完成整个流水线操作，并可以用短路操作提供更高效的实现； 无需上界（Bounds optional）：不少问题都可以被表达为无限流（infinite stream）：用户不停地读取流直到满意的结果出现为止（比如说，枚举完美数这个操作可以被表达为在所有整数上进行过滤）。 集合是有限的，但流不是（操作无限流时我们必需使用短路操作，以确保操作可以在有限时间内完成）； 从API的角度来看，流和集合完全互相独立，不过我们可以既把集合作为流的数据源（Collection拥有stream()和parallelStream()方法），也可以通过流产生一个集合（使用前例的collect()方法）。 Collection以外的类型也可以作为stream的数据源，比如JDK中的BufferedReader、Random和BitSet已经被改造可以用做流的数据源，Arrays.stream()则产生给定数组的流视图。事实上，任何可以用Iterator描述的对象都可以成为流的数据源，如果有额外的信息（比如大小、是否有序等特性），库还可以进行进一步的优化。 惰性（Laziness）过滤和映射这样的操作既可以被急性求值（以filter为例，急性求值需要在方法返回前完成对所有元素的过滤），也可以被惰性求值（用Stream代表过滤结果，当且仅当需要时才进行过滤操作）在实际中进行惰性运算可以带来很多好处。比如说，如果我们进行惰性过滤，我们就可以把过滤和流水线里的其它操作混合在一起，从而不需要对数据进行多遍遍历。相类似的，如果我们在一个大型集合里搜索第一个满足某个条件的元素，我们可以在找到后直接停止，而不是继续处理整个集合。（这一点对无限数据源是很重要，惰性求值对于有限数据源起到的是优化作用，但对无限数据源起到的是决定作用，没有惰性求值，对无限数据源的操作将无法终止）对于过滤和映射这样的操作，我们很自然的会把它当成是惰性求值操作，不过它们是否真的是惰性取决于它们的具体实现。另外，像sum()这样生成值的操作和forEach()这样产生副作用的操作都是“天然急性求值”，因为它们必须要产生具体的结果。 以下面的流水线为例： int sum = shapes.stream() .filter(s -&gt; s.getColor() == BLUE) .mapToInt(s -&gt; s.getWeight()) .sum(); 这里的过滤操作和映射操作是惰性的，这意味着在调用sum()之前，我们不会从数据源提取任何元素。在sum操作开始之后，我们把过滤、映射以及求和混合在对数据源的一遍遍历之中。这样可以大大减少维持中间结果所带来的开销。大多数循环都可以用数据源（数组、集合、生成函数以及I/O管道）上的聚合操作来表示：进行一系列惰性操作（过滤和映射等操作），然后用一个急性求值操作（forEach，toArray和collect等操作）得到最终结果——例如过滤—映射—累积，过滤—映射—排序—遍历等组合操作。惰性操作一般被用来计算中间结果，这在Streams API设计中得到了很好的体现——与其让filter和map返回一个集合，我们选择让它们返回一个新的流。在Streams API中，返回流对象的操作都是惰性操作，而返回非流对象的操作（或者无返回值的操作，例如forEach()）都是急性操作。 绝大多数情况下，潜在的惰性操作会被用于聚合，这正是我们想要的——流水线中的每一轮操作都会接收输入流中的元素，进行转换，然后把转换结果传给下一轮操作。在使用这种数据源—惰性操作—惰性操作—急性操作流水线时，流水线中的惰性几乎是不可见的，因为计算过程被夹在数据源和最终结果（或副作用操作）之间。这使得API的可用性和性能得到了改善。对于anyMatch(Predicate)和findFirst()这些急性求值操作，我们可以使用短路（short-circuiting）来终止不必要的运算。以下面的流水线为例： Optional&lt;Shape&gt; firstBlue = shapes.stream() .filter(s -&gt; s.getColor() == BLUE) .findFirst(); 由于过滤这一步是惰性的，findFirst在从其上游得到一个元素之后就会终止，这意味着我们只会处理这个元素及其之前的元素，而不是所有元素。findFirst()方法返回Optional对象，因为集合中有可能不存在满足条件的元素。Optional是一种用于描述可缺失值的类型。在这种设计下，用户并不需要显式进行惰性求值，甚至他们都不需要了解惰性求值。类库自己会选择最优化的计算方式。 并行（Parallelism）流水线既可以串行执行也可以并行执行，并行或串行是流的属性。除非你显式要求使用并行流，否则JDK总会返回串行流。（串行流可以通过parallel()方法被转化为并行流）尽管并行是显式的，但它并不需要成为侵入式的。利用parallelStream()，我们可以轻松的把之前重量求和的代码并行化： int sum = shapes.parallelStream() .filter(s -&gt; s.getColor = BLUE) .mapToInt(s -&gt; s.getWeight()) .sum(); 并行化之后和之前的代码区别并不大，然而我们可以很容易看出它是并行的（此外我们并不需要自己去实现并行代码）。因为流的数据源可能是一个可变集合，如果在遍历流时数据源被修改，就会产生干扰（interference）。所以在进行流操作时，流的数据源应保持不变（held constant）。这个条件并不难维持，如果集合只属于当前线程，只要lambda表达式不修改流的数据源就可以。（这个条件和遍历集合时所需的条件相似，如果集合在遍历时被修改，绝大多数的集合实现都会抛出ConcurrentModificationException）我们把这个条件称为无干扰性（non-interference）。 我们应避免在传递给流方法的lambda产生副作用。一般来说，打印调试语句这种输出变量的操作是安全的，然而在lambda表达式里访问可变变量就有可能造成数据竞争或是其它意想不到的问题，因为lambda在执行时可能会同时运行在多个线程上，因而它们所看到的元素有可能和正常的顺序不一致。无干扰性有两层含义： 不要干扰数据源； 不要干扰其它lambda表达式，当一个lambda在修改某个可变状态而另一个lambda在读取该状态时就会产生这种干扰。 只要满足无干扰性，我们就可以安全的进行并行操作并得到可预测的结果，即便对线程不安全的集合（例如ArrayList）也是一样。 实例（Examples） 下面的代码源自JDK中的Class类型（getEnclosingMethod方法），这段代码会遍历所有声明的方法，然后根据方法名称、返回类型以及参数的数量和类型进行匹配： for (Method method : enclosingInfo.getEnclosingClass().getDeclaredMethods()) &#123; if (method.getName().equals(enclosingInfo.getName())) &#123; Class&lt; ? &gt;[] candidateParamClasses = method.getParameterTypes(); if (candidateParamClasses.length == parameterClasses.length) &#123; boolean matches = true; for (int i = 0; i &lt; candidateParamClasses.length; i += 1) &#123; if (!candidateParamClasses[i].equals(parameterClasses[i])) &#123; matches = false; break; &#125; &#125; if (matches) &#123; // finally, check return type if (method.getReturnType().equals(returnType)) &#123; return method; &#125; &#125; &#125; &#125;&#125;throw new InternalError(\"Enclosing method not found\"); 通过使用流，我们不但可以消除上面代码里面所有的临时变量，还可以把控制逻辑交给类库处理。通过反射得到方法列表之后，我们利用Arrays.stream将它转化为Stream，然后利用一系列过滤器去除类型不符、参数不符以及返回值不符的方法，然后通过调用findFirst得到Optional，最后利用orElseThrow返回目标值或者抛出异常。 return Arrays.stream(enclosingInfo.getEnclosingClass().getDeclaredMethods()) .filter(m -&gt; Objects.equal(m.getName(), enclosingInfo.getName())) .filter(m -&gt; Arrays.equal(m.getParameterTypes(), parameterClasses)) .filter(m -&gt; Objects.equals(m.getReturnType(), returnType)) .findFirst() .orElseThrow(() -&gt; new InternalError(\"Enclosing method not found\")); 相对于未使用流的代码，这段代码更加紧凑，可读性更好，也不容易出错。流操作特别适合对集合进行查询操作。假设有一个“音乐库”应用，这个应用里每个库都有一个专辑列表，每张专辑都有其名称和音轨列表，每首音轨表都有名称、艺术家和评分。假设我们需要得到一个按名字排序的专辑列表，专辑列表里面的每张专辑都至少包含一首四星及四星以上的音轨，为了构建这个专辑列表，我们可以这么写： List&lt;Album&gt; favs = new ArrayList&lt;&gt;();for (Album album : albums) &#123; boolean hasFavorite = false; for (Track track : album.tracks) &#123; if (track.rating &gt;= 4) &#123; hasFavorite = true; break; &#125; &#125; if (hasFavorite) favs.add(album);&#125;Collections.sort(favs, new Comparator&lt;Album&gt;() &#123; public int compare(Album a1, Album a2) &#123; return a1.name.compareTo(a2.name); &#125;&#125;); 我们可以用流操作来完成上面代码中的三个主要步骤——识别一张专辑是否包含一首评分大于等于四星的音轨（使用anyMatch）；按名字排序；以及把满足条件的专辑放在一个List中： List&lt;Album&gt; sortedFavs = albums.stream() .filter(a -&gt; a.tracks.anyMatch(t -&gt; (t.rating &gt;= 4))) .sorted(Comparator.comparing(a -&gt; a.name)) .collect(Collectors.toList()); Compartor.comparing方法接收一个函数（该函数返回一个实现了Comparable接口的排序键值），然后返回一个利用该键值进行排序的Comparator（请参考下面的比较器工厂一节）。 收集器（Collectors）在之前的例子中，我们利用collect()方法把流中的元素聚合到List或Set中。collect()接收一个类型为Collector的参数，这个参数决定了如何把流中的元素聚合到其它数据结构中。Collectors类包含了大量常用收集器的工厂方法，toList()和toSet()就是其中最常见的两个，除了它们还有很多收集器，用来对数据进行对复杂的转换。Collector的类型由其输入类型和输出类型决定。以toList()收集器为例，它的输入类型为T，输出类型为List，toMap是另外一个较为复杂的Collector，它有若干个版本。最简单的版本接收一对函数作为输入，其中一个函数用来生成键（key），另一个函数用来生成值（value）。toMap的输入类型是T，输出类型是Map&lt;K, V&gt;，其中K和V分别是前面两个函数所生成的键类型和值类型。（复杂版本的toMap收集器则允许你指定目标Map的类型或解决键冲突）。举例来说，下面的代码以目录数字为键值创建一个倒排索引： Map&lt;Integer, Album&gt; albumsByCatalogNumber = albums.stream() .collect(Collectors.toMap(a -&gt; a.getCatalogNumber(), a -&gt; a)); groupingBy是一个与toMap相类似的收集器，比如说我们想要把我们最喜欢的音乐按歌手列出来，这时我们就需要这样的Collector：它以Track作为输入，以Map&lt;Artist, List&gt; 作为输出。groupingBy收集器就可以胜任这个工作，它接收分类函数（classification function），然后根据这个函数生成Map，该Map的键是分类函数的返回结果，值是该分类下的元素列表。 Map&lt;Artist, List&lt;Track&gt;&gt; favsByArtist = tracks.stream() .filter(t -&gt; t.rating &gt;= 4) .collect(Collectors.groupingBy(t -&gt; t.artist)); 收集器可以通过组合和复用来生成更加复杂的收集器，简单版本的groupingBy收集器把元素按照分类函数为每个元素计算出分类键值，然后把输入元素输出到对应的分类列表中。除了这个版本，还有一个更加通用（general）的版本允许你使用其它收集器来整理输入元素：它接收一个分类函数以及一个下流（downstream）收集器（单参数版本的groupingBy使用toList()作为其默认下流收集器）。举例来说，如果我们想把每首歌曲的演唱者收集到Set而非List中，我们可以使用toSet收集器： Map&lt;Artist, Set&lt;Track&gt;&gt; favsByArtist = tracks.stream() .filter(t -&gt; t.rating &gt;= 4) .collect(Collectors.groupingBy(t -&gt; t.artist, Collectors.toSet())); 如果我们需要按照歌手和评分来管理歌曲，我们可以生成多级Map： Map&lt;Artist, Map&lt;Integer, List&lt;Track&gt;&gt;&gt; byArtistAndRating = tracks.stream() .collect(groupingBy(t -&gt; t.artist, groupingBy(t -&gt; t.rating))); 在最后的例子里，我们创建了一个歌曲标题里面的词频分布。我们首先使用Stream.flatMap()得到一个歌曲流，然后用Pattern.splitAsStream把每首歌曲的标题打散成词流；接下来我们用groupingBy和String.toUpperCase对这些词进行不区分大小写的分组，最后使用counting()收集器计算每个词出现的次数（从而无需创建中间集合）。 Pattern pattern = Pattern.compile(\"\\\\s+\");Map&lt;String, Integer&gt; wordFreq = tracks.stream() .flatMap(t -&gt; pattern.splitAsStream(t.name)) // Stream&lt;String&gt; .collect(groupingBy(s -&gt; s.toUpperCase(),counting())); flatMap接收一个返回流（这里是歌曲标题里的词）的函数。它利用这个函数将输入流中的每个元素转换为对应的流，然后把这些流拼接到一个流中。所以上面代码中的flatMap会返回所有歌曲标题里面的词，接下来我们不区分大小写的把这些词分组，并把词频作为值（value）储存。Collectors类包含大量的方法，这些方法被用来创造各式各样的收集器，以便进行查询、列表（tabulation）和分组等工作，当然你也可以实现一个自定义Collector。并行的实质（Parallelism under the hood）Java SE 7引入了Fork/Join模型，以便高效实现并行计算。不过，通过Fork/Join编写的并行代码和同功能的串行代码的差别非常巨大，这使改写串行代码变的非常困难。通过提供串行流和并行流，用户可以在串行操作和并行操作之间进行便捷的切换（无需重写代码），从而使得编写正确的并行代码变的更加容易。 为了实现并行计算，我们一般要把计算过程递归分解（recursive decompose）为若干步： 把问题分解为子问题； 串行解决子问题从而得到部分结果（partial result）； 合并部分结果合为最终结果。 这也是Fork/Join的实现原理。为了能够并行化任意流上的所有操作，我们把流抽象为Spliterator，Spliterator是对传统迭代器概念的一个泛化。分割迭代器（spliterator）既支持顺序依次访问数据，也支持分解数据：就像Iterator允许你跳过一个元素然后保留剩下的元素，Spliterator允许你把输入元素的一部分（一般来说是一半）转移（carve off）到另一个新的Spliterator中，而剩下的数据则会被保存在原来的Spliterator里。（这两个分割迭代器还可以被进一步分解）除此之外，分割迭代器还可以提供源的元数据（比如元素的数量，如果已知的话）和其它一系列布尔值特征（比如说“元素是否被排序”这样的特征），Streams框架可以利用这些数据来进行优化。 上面的分解方法也同样适用于其它数据结构，数据结构的作者只需要提供分解逻辑，然后就可以直接享用并行流操作带来的遍历。大多数用户无需去实现Spliterator接口，因为集合上的stream()方法往往就足够了。但如果你需要实现一个集合或一个流，那么你可能需要手动实现Spliterator接口。Spliterator接口的API如下所示： public interface Spliterator&lt;T&gt; &#123; // Element access boolean tryAdvance(Consumer&lt; ? super T&gt; action); void forEachRemaining(Consumer&lt; ? super T&gt; action); // Decomposition Spliterator&lt;T&gt; trySplit(); //Optional metadata long estimateSize(); int characteristics(); Comparator&lt; ? super T&gt; getComparator();&#125; 集合库中的基础接口Collection和Iterable都实现了正确但相对低效的spliterator()实现，但派生接口（例如Set）和具体实现类（例如ArrayList）均提供了高效的分割迭代器实现。分割迭代器的实现质量会影响到流操作的执行效率；如果在split()方法中进行良好（平衡）的划分，CPU的利用率会得到改善；此外，提供正确的特性（characteristics）和大小（size）这些元数据有利于进一步优化。 出现顺序（Encounter order）多数数据结构（例如列表，数组和I/O通道）都拥有自然出现顺序（natural encounter order），这意味着它们的元素出现顺序是可预测的。其它的数据结构（例如HashSet）则没有一个明确定义的出现顺序（这也是HashSet的Iterator实现中不保证元素出现顺序的原因）。是否具有明确定义的出现顺序是Spliterator检查的特性之一（这个特性也被流使用）。除了少数例外（比如Stream.forEach()和Stream.findAny()），并行操作一般都会受到出现顺序的限制。这意味着下面的流水线： List&lt;String&gt; names = people.parallelStream() .map(Person::getName) .collect(toList()); 代码中名字出现的顺序必须要和流中的Person出现的顺序一致。一般来说，这是我们所期待的结果，而且它对多大多数的流实现都不会造成明显的性能损耗。从另外的角度来说，如果源数据是HashSet，那么上面代码中名字就可以以任意顺序出现。 JDK中的流和lambda（Streams and lambdas in JDK）Stream在Java SE 8中非常重要，我们希望可以在JDK中尽可能广的使用Stream。我们为Collection提供了stream()和parallelStream()，以便把集合转化为流；此外数组可以通过Arrays.stream()被转化为流。除此之外，Stream中还有一些静态工厂方法（以及相关的原始类型流实现），这些方法被用来创建流，例如Stream.of()，Stream.generate以及IntStream.range。其它的常用类型也提供了流相关的方法，例如String.chars，BufferedReader.lines，Pattern.splitAsStream，Random.ints和BitSet.stream。最后，我们提供了一系列API用于构建流，类库的编写者可以利用这些API来在流上实现其它聚集操作。实现Stream至少需要一个Iterator，不过如果编写者还拥有其它元数据（例如数据大小），类库就可以通过Spliterator提供一个更加高效的实现（就像JDK中所有的集合一样）。 比较器工厂（Comparator factories）我们在Comparator接口中新增了若干用于生成比较器的实用方法：静态方法Comparator.comparing()接收一个函数（该函数返回一个实现Comparable接口的比较键值），返回一个Comparator，它的实现十分简洁： public static &lt;T, U extends Comparable&lt; ? super U&gt;&gt; Compartor&lt;T&gt; comparing( Function&lt; ? super T, ? extends U&gt; keyExtractor) &#123; return (c1, c2) -&gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));&#125; 我们把这种方法称为高阶函数——以函数作为参数或是返回值的函数。我们可以使用高阶函数简化代码： List&lt;Person&gt; people = ...people.sort(comparing(p -&gt; p.getLastName())); 这段代码比“过去的代码”（一般要定义一个实现Comparator接口的匿名类）要简洁很多。但是它真正的威力在于它大大改进了可组合性（composability）。举例来说，Comparator拥有一个用于逆序的默认方法。于是，如果想把列表按照姓进行反序排序，我们只需要创建一个和之前一样的比较器，然后调用反序方法即可： people.sort(comparing(p -&gt; p.getLastName()).reversed()); 与之类似，默认方法thenComparing允许你去改进一个已有的Comparator：在原比较器返回相等的结果时进行进一步比较。下面的代码演示了如何按照姓和名进行排序： Comparator&lt;Person&gt; c = Comparator.comparing(p -&gt; p.getLastName()) .thenComparing(p -&gt; p.getFirstName());people.sort(c); 可变的集合操作（Mutative collection operation）集合上的流操作一般会生成一个新的值或集合。不过有时我们希望就地修改集合，所以我们为集合（例如Collection，List和Map）提供了一些新的方法，比如Iterable.forEach(Consumer)，Collection.removeAll(Predicate)，List.replaceAll(UnaryOperator)，List.sort(Comparator)和Map.computeIfAbsent()。除此之外，ConcurrentMap中的一些非原子方法（例如replace和putIfAbsent）被提升到Map之中。 小结（Summary）引入lambda表达式是Java语言的巨大进步，但这还不够——开发者每天都要使用核心类库，为了开发者能够尽可能方便的使用语言的新特性，语言的演化和类库的演化是不可分割的。Stream抽象作为新增类库特性的核心，提供了强大的数据集合操作功能，并被深入整合到现有的集合类和其它的JDK类型中。","categories":[{"name":"java","slug":"java","permalink":"http://liuyiyou.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://liuyiyou.cn/tags/java/"}]},{"title":"SpringCloud学习-Sleuth","slug":"SpringCloud学习-Sleuth","date":"2017-11-16T16:00:00.000Z","updated":"2019-02-09T14:09:30.581Z","comments":true,"path":"SpringCloud学习-Sleuth/","link":"","permalink":"http://liuyiyou.cn/SpringCloud学习-Sleuth/","excerpt":"","text":"Sleuth是什么分布式服务跟踪","categories":[{"name":"spring-cloud","slug":"spring-cloud","permalink":"http://liuyiyou.cn/categories/spring-cloud/"}],"tags":[{"name":"spring-cloud","slug":"spring-cloud","permalink":"http://liuyiyou.cn/tags/spring-cloud/"}]},{"title":"SpringCloud学习-Zuul","slug":"SpringCloud学习-Zuul","date":"2017-11-13T16:00:00.000Z","updated":"2019-04-09T08:47:04.617Z","comments":true,"path":"SpringCloud学习-Zuul/","link":"","permalink":"http://liuyiyou.cn/SpringCloud学习-Zuul/","excerpt":"","text":"Zuul是什么Zuul是一个API网关服务，为所有客户端请求或其他消费提供统一的网关，通过该网关接入不同的微服务，并隐藏架构实现的细节 通过Zuul组件，可以完成以下功能 动态路由 监控与审查 身份认证与安全 压力测试 金丝雀、A/B测试 服务迁移 负载剪裁/限流 路由配置规则 默认与Eureka服务整合自动根据微服务ID进行映射 结合微服务ID通过自定义方式进行路由映射 直接使用静态URL路径的方式对微服务进行路由映射 添加全局路由器映射 通过自定义路由转换器，实现灵活的路由映射 默认与Eureka服务整合自动根据微服务ID进行映射如果有Eureka时，Zuul会自动为注册到服务器上的服务创建一个默认的规则：访问路径的前缀为serivceId配置的服务名称 http://[zuul路由服务器地址]/[serviceId]/[具体的服务的端点] http://localhost:8200/hello-service/base。 其中http://localhost:8200是Zuul的地址 hello-service是另外一个服务 /base是hello-service的一个方法 图：见印象笔记-》读书笔记-》Spring Cloud微服务实战 ——》 第六章 结合微服务ID通过自定义方式进行路由映射zuul.routes.serviceId=指定路径 zuul.routes.hello-service=/hello/** 直接使用静态URL路径的方式对微服务进行路由映射对于没有注册到Eureka服务器中的微服务，可以通过Zuul路由服务器中配置静态url来进行服务的路由映射 zuul.routes.python-sevice.path = /pythonservice/**zuul.routes.python-service.url = http://paythonServe:8888 注意点默认情况下,zuul不会将敏感的http首部,如(Cookie,Set-Cookie)和Authorization转发到下游服务,要让Zuul传播HTTP首部Authorization,需要在zuul服务网关的application.yml或者application.properties中,设置以下配置: zuul.sensitive-headers=&quot;Cookie&quot;, &quot;Set-Cookie&quot;, &quot;Authorization&quot;","categories":[{"name":"spring-cloud","slug":"spring-cloud","permalink":"http://liuyiyou.cn/categories/spring-cloud/"}],"tags":[{"name":"spring-cloud","slug":"spring-cloud","permalink":"http://liuyiyou.cn/tags/spring-cloud/"}]},{"title":"SpringCloud学习-Hystrix","slug":"SpringCloud学习-Hystrix","date":"2017-11-13T16:00:00.000Z","updated":"2019-02-09T14:09:24.473Z","comments":true,"path":"SpringCloud学习-Hystrix/","link":"","permalink":"http://liuyiyou.cn/SpringCloud学习-Hystrix/","excerpt":"","text":"Hystrix是什么Hystrix是用来做微服务容错保护的库，可以解决如下问题 对第三方接口/依赖服务潜在的调用失败提供保护和控制机制 在分布式系统中隔离资源，降低耦合，防止服务之间相互调用而导致级联失败 开始失败以及迅速恢复 设计理念 防止单个服务的故障而耗尽系统容器和线程资源 快速失败，而不是在队列中积压服务请求 提供服务降级（fallback）处理机制 使用隔离技术来隔离服务依赖之间的影响 通过近乎试试的监控和告警，几十发现系统中潜在的为 通过配置更改可以优化低延迟传播的恢复时间 开发下面通过一个demo来演Hystrix的开发 引入Hystrix依赖开启Hystrix支持启动和测试","categories":[{"name":"spring-cloud","slug":"spring-cloud","permalink":"http://liuyiyou.cn/categories/spring-cloud/"}],"tags":[{"name":"spring-cloud","slug":"spring-cloud","permalink":"http://liuyiyou.cn/tags/spring-cloud/"}]},{"title":"SpringCloud学习-Feigh","slug":"SpringCloud学习-Feigh","date":"2017-11-12T16:00:00.000Z","updated":"2019-02-08T14:02:12.251Z","comments":true,"path":"SpringCloud学习-Feigh/","link":"","permalink":"http://liuyiyou.cn/SpringCloud学习-Feigh/","excerpt":"","text":"目的 学会使用Feigh声明式服务调用 在RPC框架中，服务调用一般是服务的暴露接口，并提供客户端API，客户端在添加依赖后，即可像本地方法一样调用远程服务，SpringCloud也提供了类似需求，而在此之前，使用的是RestTemplate调用，所需的参数是在url中进行拼接，如果参数过多的时候不好拼接，另外，不容易进行管理，更好的替代方案是使用Feigh Feigh是一个声明式的web service客户端，可以像调用本地方法一样调用远程方法 Feigh整合了RIbbon和Hystrix 特性 可插拔注解支持，包括Feigh注解和Jax-RS注解 支持可插拔的Http编码器和解码器 支持Hystrix和它的回退功能 支持Ribbon负载均衡 支持Http请求和响应的压缩处理 准备工作需要4个项目： eureka-server：服务注册中心 user-service-feigh-api：服务API，客户端依赖，user-service-feigh-impl：服务实现放 ，user-service-client：服务消费方 提供一个供服务方和消费方共用的api接口 user-service-feigh-api 提供一个增删改查的用户服务 user-service-feigh-impl 体统一个调用user-srvice的客户端 user-service-client Eureka服务中心搭建参考SpringCloud学习-Eureka 服务提供方新建项目：user-service-api 该项目仅仅提供服务API，并不需要启动，服务提供方和服务消费方都依赖该项目，实际情况下，该项目应该写在user-service-feigh-impl中，通过不同的打包方式将该项目打包出来，由各个服务方调用 添加依赖&lt;!--1.x的 不使用了--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 提供API只有接口，没有实现 @FeignClient(\"USER-SERVICE\")public interface UserService &#123; @RequestMapping(\"add-user\") String addUser(); @RequestMapping(\"list-user\") List&lt;User&gt; listUser(); @RequestMapping(\"delete-user\") boolean deleteUser(); @RequestMapping(\"update-user\") String updateUser();&#125;public class User &#123; private int id; private String name; private int age; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 启动不需要启动，由user-service-feigh-impl和user-service依赖 服务实现方新建项目：user-service-feigh-impl 添加依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;cn.liuyiyou.springcloud&lt;/groupId&gt; &lt;artifactId&gt;user-service-feigh-api&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 配置文件#服务命名spring.application.name=user-service#指定服务注册中心地址eureka.client.service-url.defaultZone=http://localhost:1111/eurekaserver.port=8080 启动类@EnableDiscoveryClient@SpringBootApplicationpublic class UserServiceFeighApiApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UserServiceFeighApiApplication.class, args); &#125;&#125; 服务实现类注意： 实现了UserService接口，确保声明的服务都有其实现方法 包所在的名字是service，但是写的方式好像是controller，这是因为采用的是http方式进行调用 package cn.liuyiou.cloud.service;import cn.liuyiou.cloud.model.User;import com.google.common.collect.Lists;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;/** * 该注解必须是 @RestController 不能是@Service */@RestControllerpublic class UserServiceImpl implements UserService &#123; &lt;!-- @RequestMapping(\"add-user\") --&gt; @Override public String addUser() &#123; return \"add User Has Been Called\"; &#125; &lt;!-- @RequestMapping(\"list-user\") --&gt; @Override public List&lt;User&gt; listUser() &#123; return Lists.newArrayList(new User() &#123;&#123; setId(1); setAge(18); setName(\"lyy\"); &#125;&#125;, new User() &#123;&#123; setId(2); setAge(18); setName(\"yi\"); &#125;&#125;, new User() &#123;&#123; setId(1); setAge(18); setName(\"you\"); &#125;&#125;); &#125; &lt;!-- @RequestMapping(\"delete-user\") --&gt; @Override public boolean deleteUser() &#123; return true; &#125; &lt;!-- @RequestMapping(\"update-user\") --&gt; @Override public String updateUser() &#123; return \"update User Has Been Called\"; &#125;&#125; 启动观察是否注册到服务中心中了 服务调用方新建项目user-service-client 添加依赖因为只是调用方，该依赖可以不添加 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件因为只是调用方，该配置可以不添加 #服务命名spring.application.name=hello-service#指定服务注册中心地址eureka.client.service-url.defaultZone=http://localhost:1111/eurekaserver.port=10000#需要启动eureka-server后启动,再看 http://localhost:1111/ 会发现hello-service已经注册到服务中心中去了 添加注释因为只是调用方，该@EnableDiscoveryClient可以不添加 注意： 因为UserService是单独编译一个jar包，所以在使用@EnableFeignClients注解时需要指定basePackages的值,否则报错:Consider defining a bean of type ‘cn.liuyiou.cloud.service.api.Service’ in your configuration. /** * 因为UserService是单独编译一个jar包，所以在使用@EnableFeignClients注解时需要指定basePackages的值,否则报错 * Consider defining a bean of type 'cn.liuyiou.cloud.service.api.Service' in your configuration. */@EnableFeignClients(basePackages = \"cn.liuyiou.cloud.service.api\")@SpringBootApplication@EnableDiscoveryClientpublic class UserServiceClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UserServiceClientApplication.class, args); &#125;&#125; 调用服务package cn.liuyiou.cloud.controller;import cn.liuyiou.cloud.model.User;import cn.liuyiou.cloud.service.UserService;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.PostConstruct;import java.util.List;@RestControllerpublic class UserController &#123; private Logger logger = LoggerFactory.getLogger(UserController.class); @Autowired private UserService userService; public UserController() &#123; logger.info(\"userservice In Construct &#123;&#125;\", userService); &#125; @PostConstruct public void printService()&#123; logger.info(\"userservice In PostConstruct::&#123;&#125;\", userService); &#125; @RequestMapping(\"/add-user\") public String saveUser() &#123; return userService.addUser(); &#125; @RequestMapping(\"/list-user\") public List&lt;User&gt; getUser() &#123; logger.info(\"userservice In Method ::&#123;&#125;\", userService); List&lt;User&gt; userList = userService.listUser(); return userList; &#125; @RequestMapping(\"/edit-user\") public String editUser() &#123; return userService.updateUser(); &#125; @RequestMapping(\"/delete-user\") public Boolean deleteUser() &#123; return userService.deleteUser(); &#125;&#125; 启动 userservice In Construct null userservice In PostConstruct::HardCodedTarget(type=UserService, name=USER-SERVICE, url=http://USER-SERVICE) userservice In Method ::HardCodedTarget(type=UserService, name=USER-SERVICE, url=http://USER-SERVICE) 访问 ： http://localhost:8081/list-user [&#123;\"id\":1,\"name\":\"lyy\",\"age\":18&#125;,&#123;\"id\":2,\"name\":\"yi\",\"age\":18&#125;,&#123;\"id\":1,\"name\":\"you\",\"age\":18&#125;] API和IMP合二为一具体的目录规范需要自己定义 &lt;groupId&gt;cn.liuyiyou.springcloud&lt;/groupId&gt; &lt;artifactId&gt;user-service-api&lt;/artifactId&gt; &lt;version&gt;0.0.2-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;user-service-api&lt;/name&gt;&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;configuration&gt; &lt;includes&gt; &lt;include&gt;cn/liuyiyou/cloud/model/**/*.class&lt;/include&gt; &lt;include&gt;cn/liuyiyou/cloud/service/api/**/*.class&lt;/include&gt; &lt;/includes&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;/plugins&gt; 客户端依赖修改成 0.0.2 总结对于微服务来说，除了对其他服务提供服务之外，同时也对web层提供服务，这里有一点容易混淆，在同一个项目中的控制层如何确定是通过 声明式服务调用还是直接调用 @EnableFeignClientsProductController : produService::HardCodedTarget(type=IProductService, name=SERVICE-PRODUCT, url=http://SERVICE-PRODUCT)不加ProductController : produService::com.iba.service.product.service.ProductService@19f4620b 深入Feigh来自《Spring Cloud 微服务架构开发实战》 Feigh参数绑定Feigh中的继承Feigh与Swagger的冲突版本太低 参考资料Spring Cloud入门教程(三)：声明式服务调用(Feign)Spring Cloud 声明式服务调用 Feign","categories":[{"name":"spring-cloud","slug":"spring-cloud","permalink":"http://liuyiyou.cn/categories/spring-cloud/"}],"tags":[{"name":"spring-cloud","slug":"spring-cloud","permalink":"http://liuyiyou.cn/tags/spring-cloud/"}]},{"title":"SpringCloud学习-Ribbon","slug":"SpringCloud学习-Ribbon","date":"2017-11-11T16:00:00.000Z","updated":"2019-02-08T14:00:20.041Z","comments":true,"path":"SpringCloud学习-Ribbon/","link":"","permalink":"http://liuyiyou.cn/SpringCloud学习-Ribbon/","excerpt":"","text":"引入Ribbon&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 上面这个包含了Ribbon，如果不想引入这么多，可以只引入Ribbon&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;&lt;/dependency&gt; 开启负载均衡@EnableDiscoveryClient@SpringBootApplicationpublic class RibbonApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RibbonApplication.class, args); &#125; @Bean /** * 开启客户端负载均衡 */ @LoadBalanced public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125;@RestControllerpublic class RibbonConsumerController &#123; @Autowired private RestTemplate restTemplate; //并没有指定服务端口，只是指定了服务名称即可发生调用 @GetMapping(\"/ribbon\") public String helloRibbon() &#123; return restTemplate.getForEntity(\"http://HELLO-SERVICE/base\", String.class).getBody(); &#125;&#125; 实现原理 Ribbon首先根据其所在的zone优先选择一个负载较少的Eureka服务器 定期从Eureka服务器更新，并过滤服务实例列表 根据指定的负载均衡策略，从可用的服务实例选择一个 调用该地址，通过Rest客户端进行服务调用 扩展知识Ribbon提供了6个组件 服务器列表（ServerList）服务器列表就是客户端负载均衡所使用的各服务实例列表。Ribbon在实现上支持下面3种服务器列表方式 静态服务器列表：可以通过Ribbon中的BaseLoadBanlancer#setServersList()方法进行设置 基于配置的服务器列表：需要在项目中通过配置文件&lt;服务名称&gt;.ribbon.listOfServers属性进行设置。代码如下: # 这里为用户服务配置了3个服务器列表userservice.ribbon.listOfServers=http://127.0.0.1:100001,http://127.0.0.1:100002,http://127.0.0.1:100003 基于服务发现的服务列表 服务器列表过滤器（ServerListFilter） 服务实例存货探测（IPing） 负载均衡策略（IRule） 负载均衡器（ILoadBanlace） 服务调用器（RestClient）","categories":[{"name":"spring-cloud","slug":"spring-cloud","permalink":"http://liuyiyou.cn/categories/spring-cloud/"}],"tags":[{"name":"spring-cloud","slug":"spring-cloud","permalink":"http://liuyiyou.cn/tags/spring-cloud/"}]},{"title":"SpringCloud学习-Eureka","slug":"SpringCloud学习-Eureka","date":"2017-11-10T16:00:00.000Z","updated":"2019-02-08T13:10:51.365Z","comments":true,"path":"SpringCloud学习-Eureka/","link":"","permalink":"http://liuyiyou.cn/SpringCloud学习-Eureka/","excerpt":"","text":"Eureka是什么，SpringCloud用Eureka来干什么等等相关概念就不细说了，网上有大把大把的解释，甚至下面的文章都不需要看，因为网上也有大把大把的列子，为了省去搜索的时间，可以参考：Spring资料大全 中的SpringCloud相关文档。本文的目的只是自己记录一下 目的 Eureka服务中心搭建 其他服务注册到Eureka服务中心 Eureka服务中心高可用 Eureka服务中心相关配置详解 需要三个项目： eureka-server：服务注册中心，base-service-producer：服务提供方，hello-service：服务调用方（也可以是另外一个服务） Eureka服务中心搭建新建项目：eureka-server添加依赖&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;properties&gt; &lt;spring-cloud.version&gt;Finchley.SR2&lt;/spring-cloud.version&gt; &lt;maven.skip.test&gt;true&lt;/maven.skip.test&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 添加注解@EnableEurekaServer 和 @EnableDiscoveryClient 都能开启服务注册效果，不过前者只针对Eureka的服务注册，来自于SCN，而后者是来自spring-cloud-commons，能用于其他服务注册 /** * 该注解启动一个服务注册中心给其他应用进行对话 *///@EnableEurekaServer/** * 更加通用，如果使用了Consoule也能进行发现 */@EnableDiscoveryClient@SpringBootApplicationpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; 增加配置eureka: instance: hostname: localhost client: service-url: defaultZoon: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka fetch-registry: false #表示启动后，不需要同步已注册的服务注册列表数据到本地 register-with-eureka: false #作为服务端不需要注册自己 启动启动后,打开 http://localhost:4001/ 如果出息正常界面表示服务注册中心已经正常启动 其他服务注册到Eureka服务中心新建项目：hello-service添加依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-commons&lt;/artifactId&gt;&lt;/dependency&gt; &lt;!--这个包括上面的，2.x和1.x包名改动还挺大的--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 安全配置文件#服务命名spring.application.name=hello-service#指定服务注册中心地址eureka.client.service-url.defaultZone=http://localhost:4001/eurekaserver.port=10000#需要启动eureka-server后启动,再看 http://localhost:1111/ 会发现hello-service已经注册到服务中心中去了 添加注解因为只是调用方，该@EnableDiscoveryClient可以不添加 @EnableDiscoveryClient@SpringBootApplicationpublic class HelloServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HelloServiceApplication.class, args); &#125;&#125; 调用服务import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cloud.client.ServiceInstance;import org.springframework.cloud.client.discovery.DiscoveryClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @Autowired private DiscoveryClient discoveryClient; @GetMapping(\"/hello\") public String index() &#123; return \"Hello Spring Cloud\"; &#125; @GetMapping(\"/base\") public String baseSerivce() &#123; List&lt;String&gt; services = discoveryClient.getServices(); if (!services.isEmpty()) &#123; ServiceInstance instance = discoveryClient.getInstances(services.get(0)).get(0); String url = \"http://\" + instance.getHost() + \":\" + instance.getPort() + \"/\" + instance.getServiceId(); return url; &#125; else &#123; return \"no service\"; &#125; &#125;&#125; 启动http://localhost:10000/base 刚开始启动，会返回no service， 一个服务实例注册到Eureka大概是30秒左右，Eureka要求服务提供者必须发送3次心跳后才认为该服务实例已经就绪。 30秒后，就可以看到 http://192.168.1.101:10000/HELLO-SERVICE 同时，Eureka服务注册中心服务列表中能看到hello-service已经注册到服务注册中心中去了 Eureka安全服务端配置像上面那样Eureka服务注册中心是可以直接访问的，这样任何人只要知道ip地址就能登陆，如果需要用户名和密码访问，则application.yml做如下改动 根据官方文档配置如下，好像并没有起作用 eureka: username: lyy password: 123456 instance: hostname: localhost status-page-url: $&#123;server.servlet.path&#125;/info health-check-url-path: $&#123;server.servlet.path&#125;/health client: service-url: defaultZoon: http://$&#123;eureka.username&#125;:$&#123;eureka.password&#125;@$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka fetch-registry: false #表示启动后，不需要同步已注册的服务注册列表数据到本地 register-with-eureka: false #作为服务端不需要注册自己 同时，在pom中增加&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 还是没有起作用。 最后这样配置： eureka: instance: hostname: localhost status-page-url: $&#123;server.servlet.path&#125;/info health-check-url-path: $&#123;server.servlet.path&#125;/health client: service-url: defaultZoon: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka fetch-registry: false #表示启动后，不需要同步已注册的服务注册列表数据到本地 register-with-eureka: false #作为服务端不需要注册自己spring: security: user: name: lyy password: 123456 虽然起作用了，但是已经与Eureka无关了。 为了让客户端能够注册到Eureka—Server，还需要加上如下类： @EnableWebSecurityclass WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.csrf().ignoringAntMatchers(\"/eureka/**\"); super.configure(http); &#125;&#125; 原因如下： You can secure your Eureka server simply by adding Spring Security to your server’s classpath via spring-boot-starter-security. By default when Spring Security is on the classpath it will require that a valid CSRF token be sent with every request to the app. Eureka clients will not generally possess a valid cross site request forgery (CSRF) token you will need to disable this requirement for the /eureka/** endpoints. 客户端另外，其他服务注册到该服务注册中心时，需要将用户名和密码带上 eureka.client.service-url.defaultZone=http://lyy:123456@localhost:4001/eureka Eureka服务中心高可用application-peer1.propertiesspring.application.name=high-eureka-serviceserver.port=1111eureka.instance.hostname=peer1eureka.client.service-url.defaultZone=http://peer2:1112/eureka/#需要在/etc/hosts中 加上 ip到host的映射 127.0.0.1 peer2#在target 中运行#java -jar high-eureka-server-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer1#java -jar high-eureka-server-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer2#后访问 http://localhost:1112/ http://localhost:1111/ 可用看到将两个注册中心都当做服务注册到了注册中心中 application-peer2.propertiesspring.application.name=high-eureka-serviceserver.port=1112eureka.instance.hostname=peer2eureka.client.service-url.defaultZone=http://peer1:1111/eureka/#需要在/etc/hosts中 加上 ip到host的映射 127.0.0.1 peer1 启动访问 http://localhost:1111/访问 http://localhost:1112/ 两者互相注册 Eureka服务中心相关配置详解","categories":[{"name":"spring-cloud","slug":"spring-cloud","permalink":"http://liuyiyou.cn/categories/spring-cloud/"}],"tags":[{"name":"spring-cloud","slug":"spring-cloud","permalink":"http://liuyiyou.cn/tags/spring-cloud/"}]},{"title":"冒泡排序","slug":"冒泡排序","date":"2015-01-05T16:00:00.000Z","updated":"2019-04-23T08:24:50.467Z","comments":true,"path":"冒泡排序/","link":"","permalink":"http://liuyiyou.cn/冒泡排序/","excerpt":"","text":"概述冒泡排序：它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名 动画演示:排序过程 算法原理冒泡排序算法的运作如下：（从后往前） 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较 算法分析时间复杂度若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数$$C$$和记录移动次数$$M$$均达到最小值:$$C_{min}=n-1$$,$$M_{min}=0$$。所以，冒泡排序最好的时间复杂度为$$O(n)$$ 。 若初始文件是反序的，需要进行$$n-1$$趟排序。每趟排序要进行$$n-i$$次关键字的比较($$1≤i≤n-1$$),且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值： $$C_{max} = \\left(n(n-1)\\over 2 \\right) = O(n^2)$$ $$M_{max} = \\frac{3n(n-1)}{2} = O(n^2)$$ 冒泡排序的最坏时间复杂度为$$O(n^2)$$ 。 综上，因此冒泡排序总的平均时间复杂度为$$O(n^2)$$ 算法稳定性冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。 算法描述package cn.liuyiyou.sort;/** * 冒泡排序： * User: liuyiyou * Date: 13-1-1 * Time: 下午4:04 */public class BubbleSort &#123; /** * 这个是冒泡排序，冒泡排序是待排序的数和后面相邻的数比较大小 * 注意内层循环中j的取值变化，之前i的初始值是1，j的临界值是array.length。 * @param array */ public static void bubbleSort1(int[] array)&#123; for (int i=0;i&lt;array.length;i++)&#123; for (int j = 0; j&lt;array.length-i-1;j++ )&#123; if (array[j] &gt; array[j+1])&#123; SortUtil.swap(array,j,j+1); &#125; &#125; SortUtil.print(array, i); &#125; &#125; public static void bubbleSort2(int[] array)&#123; for (int i=0;i&lt;array.length;i++)&#123; for (int j = 0; j&lt; i;j++ )&#123; if (array[i]&lt;array[j])&#123; SortUtil.swap(array,i,j); &#125; &#125; SortUtil.print(array, i); &#125; &#125; public static void bubbleSort3(int[] array) &#123; for (int i = 0; i &lt; array.length - 1; i++) &#123; // 最多做n-1趟排序 // 对当前无序区间score[0......length-i-1]进行排序(j的范围很关键，这个范围是在逐步缩小的) for (int j = 0; j &lt; array.length - i - 1; j++) &#123; if (array[j] &lt; array[j + 1]) &#123; // 把小的值交换到后面 SortUtil.swap(array, j, j + 1); &#125; &#125; SortUtil.print(array, i); &#125; &#125; public static void main(String [] args)&#123; int [] array = SortUtil.array; System.out.println(\"原始排序结果：\"); SortUtil.print(array); bubbleSort3(array); System.out.println(\"最终排序结果：\"); SortUtil.print(array); &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/tags/数据结构/"}]},{"title":"希尔排序","slug":"希尔排序","date":"2015-01-04T16:00:00.000Z","updated":"2019-04-23T08:24:31.970Z","comments":true,"path":"希尔排序/","link":"","permalink":"http://liuyiyou.cn/希尔排序/","excerpt":"","text":"概述希尔排序和直接插入排序一样，都是插入排序，但是它改进了直接插入排序，该方法又称缩小增量排序 算法原理希尔算法的运作如下：（从后往前） 先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内部进行直接插入排序，然后，取第二个增量d2&lt;d1重复上述分组和排序，直至所取的增量dt＝1，即所有记录放在同一组中进行直接插入排序为止。 一般的初次取序列的一半为增量，以后每次减半，直到增量为1。 算法流程图 算法分析时间复杂度希尔排序的时间复杂度和增量选取有关，如使用希尔增量时间复杂度为$$O(n^2)$$ ，而Hibbaard增量的希尔排序的时间复杂度为$$O(n^\\frac{3}{2})$$ ,希尔排序时间复杂度下届是$$nlog2n$$。希尔排序没有快速排序算法快$$O(nlogn)$$ 算法稳定性由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。 和直接排序进行比较来看一下希尔排序和快速排序的差别和联系 会发现基本思想和直接插入排序一模一样，只是多了一个曾脸的变化，即外面的while循环和那个increment = increment /2 //直接插入排序public static void insertSort1(int[] array) &#123; //从位置1开始，0做为哨兵 for (int i = 1; i &lt; array.length; i++) &#123; //保存当前位置到临时变量 int temp = array[i]; //将当前位置赋给紧邻的未排序的起点 int j = i; //如果未排序的数小于已排序的树 if (array[i - 1] &gt; array[i]) &#123; //向后移动一个位置 while (j &gt; 0 &amp;&amp; array[j - 1] &gt; temp) &#123; //只能是temp，不能是array[i] ,如果是array[i],在执行下面这句话的时候，array[i]会改的值被改变了 array[j] = array[j - 1]; j--; &#125; //将当前位置存放为i array[j] = temp; //同上，比如i为1的时候array[i]=3，array[j-1]为1，执行while里面的前移之后，array[j]=array[i]=3.而实际的情况应该是array[j] &#125; else &#123; System.out.println(i); &#125; &#125; &#125;//希尔排序public static void shellSort1(int[] array)&#123; //增量 ,初始一般为数组的一半，最后为1 int increment = array.length/2; //控制增量变化，一直到1 while (increment&gt;0)&#123; for (int i = increment ; i &lt; array.length; i++)&#123; //保存当前位置到临时变量 int temp = array[i]; //将当前位置赋给紧邻的未排序的起点 int j = i; //如果未排序的数小于已排序的树 if (array[i-increment]&gt;array[i])&#123; //向后移动increment个位置 while (j&gt;=increment &amp;&amp; array[j-increment]&gt; temp)&#123; array[j] = array[j-increment]; j = j - increment; &#125; //将当前位置存放为i array[j] = temp; //同上，比如i为1的时候array[i]=3，array[j-1]为1，执行while里面的前移之后，array[j]=array[i]=3.而实际的情况应该是array[j] &#125; else &#123; System.out.println(i); &#125; &#125; //增量为上一次的一半。因为是int类型，所以最后会到1（0就不进行除了） increment = increment/2; &#125; &#125; 算法描述package cn.liuyiyou.sort;/** * User: liuyiyou * Date: 13-1-1 * Time: 下午8:16 */public class ShellSort &#123; /** * 这个可以和前面的快速插入排序进行比较，会发现方法一模一样，只是快速插入的增量一直为1.而希尔排序增量是慢慢变小的。 * */ public static void shellSort1(int[] array)&#123; int increment = array.length/2; while (increment&gt;0)&#123; for (int i = increment ; i &lt; array.length; i++)&#123; int temp = array[i]; int j = i; if (array[i-increment]&gt;array[i])&#123; while (j&gt;=increment &amp;&amp; array[j-increment]&gt; temp)&#123; array[j] = array[j-increment]; j = j - increment; &#125; array[j] = temp; &#125; else &#123; System.out.println(i); &#125; &#125; increment = increment/2; &#125; &#125; public static void shellSort2(int[] array) &#123; int count = 0; int j = 0; int temp = 0; for (int increment = array.length / 2; increment &gt; 0; increment /= 2) &#123; count++; for (int i = increment; i &lt; array.length; i++) &#123; temp = array[i]; for (j = i; j &gt;= increment; j -= increment) &#123; if(temp &gt; array[j - increment])&#123; array[j] = array[j - increment]; &#125;else&#123; break; &#125; &#125; array[j] = temp; &#125; &#125; System.out.println(count); &#125; public static void shellSort3(int[] array) &#123; int j = 0; int temp = 0; int increment = array.length/2; while (increment&gt;0)&#123; for (int i = increment; i &lt; array.length; i++) &#123; temp = array[i]; j = i; while (j &gt;= increment) &#123; if(temp &gt; array[j - increment])&#123; array[j] = array[j - increment]; &#125;else&#123; break; &#125; j = j - increment; &#125; array[j] = temp; &#125; increment = increment/2; &#125; &#125; public static void main(String[] args) &#123; int [] array = SortUtil.array; System.out.println(\"原始排序结果：\"); SortUtil.print(array); shellSort1(array); System.out.println(\"最终排序结果：\"); SortUtil.print(array); &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/tags/数据结构/"}]},{"title":"快速排序","slug":"快速排序","date":"2015-01-03T16:00:00.000Z","updated":"2019-04-23T08:24:27.328Z","comments":true,"path":"快速排序/","link":"","permalink":"http://liuyiyou.cn/快速排序/","excerpt":"","text":"概述通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 算法原理通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 算法流程图动画演示:排序过程 算法分析时间复杂度时间复杂度：O（n*lgn） 最坏：O（n^2） 空间复杂度：O（n*lgn） 算法稳定性不稳定。 代码","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/tags/数据结构/"}]},{"title":"选择排序","slug":"选择排序","date":"2015-01-02T16:00:00.000Z","updated":"2019-04-23T08:23:56.726Z","comments":true,"path":"选择排序/","link":"","permalink":"http://liuyiyou.cn/选择排序/","excerpt":"","text":"概述选择排序：每一趟从待排序的数据元素中选出最小（或最大）的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。 原理：选择排序很简单，他的步骤如下： 从左至右遍历，找到最小(大)的元素，然后与第一个元素交换。 从剩余未排序元素中继续寻找最小（大）元素，然后与第二个元素进行交换。 以此类推，直到所有元素均排序完毕。 动画演示: 具体的排序过程 算法分析时间复杂度若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数$$C$$和记录移动次数$$M$$均达到最小值:$$C_{min}=n-1$$,$$M_{min}=0$$。所以，冒泡排序最好的时间复杂度为$$O(n)$$ 。 若初始文件是反序的，需要进行$$n-1$$趟排序。每趟排序要进行$$n-i$$次关键字的比较($$1≤i≤n-1$$),且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值： $$C_{max} = \\left(n(n-1)\\over 2 \\right) = O(n^2)$$ $$M_{max} = \\frac{3n(n-1)}{2} = O(n^2)$$ 冒泡排序的最坏时间复杂度为$$O(n^2)$$ 。 综上，因此冒泡排序总的平均时间复杂度为$$O(n^2)$$ 分析 选择排序需要花费 (N – 1) + (N – 2) + … + 1 + 0 = N(N- 1) / 2 ~ N2/2次比较 和 N-1次交换操作。 对初始数据不敏感，不管初始的数据有没有排好序，都需要经历N2/2次比较，这对于一些原本排好序，或者近似排好序的序列来说并不具有优势。在最好的情况下，即所有的排好序，需要0次交换，最差的情况，倒序，需要N-1次交换。 数据交换的次数较少，如果某个元素位于正确的最终位置上，则它不会被移动。在最差情况下也只需要进行N-1次数据交换，在所有的完全依靠交换去移动元素的排序方法中，选择排序属于比较好的一种。 算法稳定性不稳定 算法实现可以分为两大部分： 找到待排序数组中第i小的元素 将该元素与i处的元素进行交换 public static int findMinIndex(int[] array, int i) &#123; int minIndex = i; for (int j = i + 1; j &lt; array.length; j++) &#123; if (array[minIndex] &gt; array[j]) &#123; minIndex = j; &#125; &#125; System.out.println(\"第\" + (i) + \"小的\" + array[minIndex]); return minIndex; &#125;public static void swap(int[] array, int i, int minIndex) &#123; int temp = array[i]; array[i] = array[minIndex]; array[minIndex] = temp; &#125;public static void selectSort2(int[] array) &#123; for (int i = 0; i &lt; array.length; i++) &#123; int minIndex = findMinIndex(array, i); swap(array, i, minIndex); &#125; &#125; package cn.liuyiyou.sort;// 每一趟从待排序的数据元素中选出最小（或最大）的一个元素，顺序放在已排好序的数列的最后，//直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。public class SelectSort &#123; public static void selectSort3(int[] array) &#123; for (int i = 0; i &lt; array.length; i++) &#123; //默认当前位置最小 int minIndex = i; for (int j = i + 1; j &lt; array.length; j++) &#123; //如果未排序的元素比当前元素小，则将该元素的索引赋给最小元素的索引 if (array[minIndex] &gt; array[j]) minIndex = j; &#125; //第i个元素与最小元素进行交换 int temp = array[i]; array[i] = array[minIndex]; array[minIndex] = temp; &#125; &#125; //这个就是稳定算法了 public static void selectSort2(int array[]) &#123; int minIndex = 0; if ((array == null) || (array.length == 0)) return; for (int i = 0; i &lt; array.length; i++) &#123; minIndex = i;//无序区的最小数据数组下标 for (int j = i + 1; j &lt; array.length; j++) &#123;//在无序区中找到最小数据并保存其数组下标 if (array[j] &lt; array[minIndex]) &#123; minIndex = j; &#125; &#125; if (minIndex != i) &#123;//如果不是无序区的最小值位置且不是默认的第一个数据，则交换之。 //第i个元素与最小元素进行交换 int temp = array[i]; array[i] = array[minIndex]; array[minIndex] = temp; &#125; &#125; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/tags/数据结构/"}]},{"title":"插入排序","slug":"插入排序","date":"2015-01-01T16:00:00.000Z","updated":"2019-04-23T08:24:21.805Z","comments":true,"path":"插入排序/","link":"","permalink":"http://liuyiyou.cn/插入排序/","excerpt":"","text":"概述插入排序包括 直接插入排序和希尔排序 直接插入排序的基本操作是：假设第一个元素是有序的，每次从无序表中取出第一个元素，把它插入到有序表的合适位置，从而得到一个新的，记录数增1的有序表 第一种方式： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素小于前面的元素（已排序），则依次与前面元素进行比较如果小于则交换，直到找到大于该元素的就则停止； 如果该元素大于前面的元素（已排序），则重复步骤2 重复步骤2~4 直到所有元素都排好序 。 第二种方式： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素小于前面的元素（已排序），则依次与前面元素进行比较如果小于则继续与前面的的数比较，直到找到大于该元素的就则停止； 将该位置后面的元素整体移动一位，再交换 重复步骤2~4 直到所有元素都排好序 。 两种方式，第一种是逐个交换，第二种是先找到，再整体后移，最后进行交换 动画演示:排序过程 具体步骤： 算法原理直接插入排序算法的运作如下 第一个元素默认有序，从第二个元素与它前面的元素进行比较 如果第二个元素比第一个元素小，则将该元素用临时变量来保存，并将他前面的元素进行后移 一直移动到比该元素小的位置，将元素插入到该位置 算法分析时间复杂度若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数$$C$$和记录移动次数$$M$$均达到最小值:$$C_{min}=n-1$$, $$M_{min}=0$$。所以，冒泡排序最好的时间复杂度为$$O(n) 。 若初始文件是反序的，需要进行$$n-1$$趟排序。每趟排序要进行$$n-i$$次关键字的比较($$1≤i≤n-1$$),且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：$$C_{max} = \\left(n(n-1)\\over 2 \\right) = O(n^2)$$$$M_{max} = \\frac{3n(n-1)}{2} = O(n^2)$$直接排序的最坏时间复杂度为$$O(n^2)$$ 。 综上，因此冒泡排序总的平均时间复杂度为$$O(n^2)$$ ，空间复杂度为$$O(1)$$ 算法稳定性冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。 算法描述package cn.liuyiyou.sort; /** * 插入排序：插入排序包括 直接插入排序和希尔排序 直接插入排序的基本操作是：将一个记录插入到已排好序的有序列表中，从而得到一个新的，记录数增1的有序表。 */ public class InsertSort &#123; //第一种：比前面的元素小的时候，先交换 public static void insertSort2(int[] array) &#123; for (int i = 1; i &lt; array.length; i++) &#123; // 从i个元素开始，依次与i之前的元素进行比较 for (int j = i; j &gt; 0; j--) &#123; if (array[j - 1] &gt; array[j]) &#123; int temp = array[j - 1]; array[j - 1] = array[j]; array[j] = temp; &#125; else &#123; //快速退出 break; &#125; &#125; &#125; &#125; //先后移，再交换 public static void insertSort3(int[] array) &#123; for (int i = 1; i &lt; array.length; i++) &#123; int temp = array[i]; //这个可以放在if里面 int j = i; if (array[i] &lt;array[i - 1] ) &#123; for ( ; j &gt; 0 &amp;&amp; temp &lt; array[j - 1] ; j--) &#123; array[j] = array[j - 1]; &#125; array[j] = temp; &#125; &#125; &#125; //while实现 public static void insertSort2(int[] array)&#123; //从位置1开始，0做为哨兵 for (int i = 1 ; i &lt; array.length; i++)&#123; //保存当前位置到临时变量 int temp = array[i]; //将当前位置赋给紧邻的未排序的起点 int j = i; //如果未排序的数小于已排序的树 if (array[i-1]&gt;array[i])&#123; //向后移动一个位置 while (j&gt;0 &amp;&amp; array[j-1]&gt; temp)&#123; //只能是temp，不能是array[i] ,如果是array[i],在执行下面这句话的时候，array[i]会改的值被改变了 array[j] = array[j-1]; j--; &#125; //将当前位置存放为i array[j] = temp; //同上，比如i为1的时候array[i]=3，array[j-1]为1，执行while里面的前移之后，array[j]=array[i]=3.而实际的情况应该是array[j] &#125; &#125; &#125; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/tags/数据结构/"}]}]}