{"meta":{"title":"温故而知新    触类而旁通","subtitle":"In me the tiger Sniffs the rose","description":"温故而知新、触类而旁通","author":"liuyiyou","url":"http://liuyiyou.cn","root":"/"},"pages":[{"title":"关于我","date":"2015-10-26T14:37:55.000Z","updated":"2017-12-15T01:52:02.446Z","comments":true,"path":"about/index.html","permalink":"http://liuyiyou.cn/about/index.html","excerpt":"","text":"联系方式 Email：liuyiyou_cn@qq.com 二维码:"},{"title":"书单","date":"2019-04-03T06:01:05.865Z","updated":"2019-04-03T03:19:40.895Z","comments":false,"path":"books/index.html","permalink":"http://liuyiyou.cn/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2014-12-22T04:39:04.000Z","updated":"2017-04-14T03:25:16.000Z","comments":true,"path":"categories/index.html","permalink":"http://liuyiyou.cn/categories/index.html","excerpt":"","text":""},{"title":"收藏","date":"2015-10-26T14:37:55.000Z","updated":"2019-01-29T09:32:34.898Z","comments":true,"path":"inbox/index.html","permalink":"http://liuyiyou.cn/inbox/index.html","excerpt":"","text":"后台模板基于 Ant Design of Vue 实现的 Ant Design Pro Vue 版轮子 其他Spring资料大全 : 持续更新 OSX软件的安装 ：这个是我自己汇总的，包含很多常用软件或者工具的安装 自己总结的SpringBoot&amp;SpringCloud系列 深入剖析Spring Web源码 Git在线书籍 是一个完整的书籍 Java虚拟机详解 Java NIO Tiny-Spring ：这个对了解Spring源码比价有用 Mysql-Proxy ：可以解决本地无法连接线上数据库，转而通过代理来连接的问题 Elasticsearch权威指南 美团点评数据仓库开发模式演进 github明星项目 ：可以关注一下最热最火的项目 shiro官方教程 effecttive-java读书笔记"},{"title":"友链","date":"2019-04-04T01:37:40.163Z","updated":"2019-04-04T01:37:40.163Z","comments":false,"path":"links/index.html","permalink":"http://liuyiyou.cn/links/index.html","excerpt":"","text":"yiyouFun"},{"title":"标签","date":"2019-04-03T13:23:39.330Z","updated":"2019-04-03T03:19:40.897Z","comments":false,"path":"tags/index.html","permalink":"http://liuyiyou.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"公司ES优化","date":"2020-05-07T05:50:19.367Z","updated":"2020-05-07T11:36:27.395Z","comments":true,"path":"公司ES优化/","link":"","permalink":"http://liuyiyou.cn/公司ES优化/","excerpt":"","text":"写作由来最近公司一万年没用的搜索功能，突然提出了一大堆需求，但是该功能基本没人维护了， 存在的问题希望优化后能解决如下问题： 搜索关联系不高，比如我搜索小米手机，结果第一个出来的是吃的米，这个和分词有关 搜索出来的数据比较少，导致搜索某个标题比较长的商品的时候无法查询到东西 一些公司自定义的词，搜索出来的也不是自己想要的 优化方向改进中文分词器目前的分词结构 http://127.0.0.1:9200/prod_index &#123;type: \"text\",fields:- &#123;FPY:- &#123;type: \"text\",analyzer: \"pinyinFullIndexAnalyzer\"&#125;,SPY:- &#123;type: \"text\",analyzer: \"pinyinSimpleIndexAnalyzer\"&#125;&#125;,analyzer: \"ikIndexAnalyzer\"&#125;, 自定义词库优化流程新建一个项目，防止其他因素干扰","categories":[],"tags":[]},{"title":"","slug":"MySql知识点总结","date":"2019-01-02T04:55:18.411Z","updated":"2020-05-07T11:36:03.600Z","comments":true,"path":"MySql知识点总结/","link":"","permalink":"http://liuyiyou.cn/MySql知识点总结/","excerpt":"","text":"知识点总结锁索引索引数据类型一般使用的索引的数据类型为hash索引和btree索引。从查询效率来讲，hash索引会比btree快，原因如下 Hash 索引仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询。由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。 Hash 索引无法被用来避免数据的排序操作。由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算； Hash 索引不能利用部分索引键查询。 对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。 Hash 索引在任何时候都不能避免表扫描。 前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。 Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。 对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下 索引存储方式对于不同的存储引擎，索引实现细节有所不同，对于MyISAM数据表来说，数据表的数据行是在数据文件中，而索引值是在索引文件里，一个数据表可以有多个索引，所有的索引都存在一个索引文件里。索引文件里的每一个索引都是由分类的关键记录组成的，这些数组用于快速访问数据文件 InnoDB存储引擎使用的是一个表空间，在这个表空间里，它管理着所有InnoDB类型数据表的数据和索引的存储 索引的选择技巧尽量为用来搜索、分类或分组的数据列编制索引，不要为作为输出显示的数据列编制索引 ​ 综合考虑各数据列的维度势，如果索引列中的数据越多，维度越高，则索引的速度越快 ​ 对短小的值进行索引 ​ 短小的值可以让比较操作更快的完成，加快索引的查找速度 ​ 短小的值可以让索引体积更小，减少磁盘IO ​ 短小的键值意味着缓存里的索引块可以容纳更多的键值，让MySQL可以在内存中容纳更多的键 ​ 为字符串值的前缀编索引 ​ 充分利用最左边的前缀 什么情况下不走索引 使用&lt;&gt;操作符 NULL值，where子句出现is null 或is not null， 使用函数（索引不是基于函数的索引） 比较不同的数据类型state 为number ,to_char(state) =’2’，这种情况最隐蔽 当索引条件字段选择性低 同一个表中的两列（有索引）进行比较时，索引有时不被使用。 当where字句中存在not function时，比如not in、not exists、column&lt;&gt;value等情况下，索引不能被使用 当使用通配符%或者_作为查询字符串中的第一个字符时，索引不被使用 查询sql执行顺序from &gt; on &gt; join &gt; where &gt; group by &gt; with &gt; having &gt; select &gt; distinct &gt; order by &gt; limit (8)SELECT (9)DISTINCT(11)&lt;TOP_specification&gt; &lt;select_list&gt;(1)FROM &lt;left_table&gt;(3) &lt;join_type&gt; JOIN &lt;right_table&gt;(2) ON &lt;join_condition&gt;(4)WHERE &lt;where_condition&gt;(5)GROUP BY &lt;group_by_list&gt;(6)WITH &#123;CUBE | ROLLUP&#125;(7)HAVING &lt;having_condition&gt;(10)ORDER BY &lt;order_by_list&gt; 连接查询MySQL在left-jion的时候，虽然是以左表为主，但是如果关联的右边有多条数据，也就是左-右为1-N的时候，查询出来的数据会是多条。这个时候需要使用group by 另外，因为执行顺序，下面的upd.uid is not null，如果放在 on后面，不会起作用 # 某个用户下面的所有升级用户是否续费SELECT u.account, upd.* FROM ibalife_user.user_ext4c_bmc bmc LEFT JOIN ibalife_user.`user` u ON bmc.uid = u.uid LEFT JOIN ( SELECT uid, sum( amount ) FROM ibalife_busi.user_pre_upgrade WHERE STATUS = 1 AND upgrade_type = 2 AND pay_state = 2 GROUP BY uid ) upd ON bmc.uid = upd.uid WHERE parent_uid = 1000154072 AND upd.uid IS NOT NULL JSON查询查询某个json中的字段 select id,type,JSON_EXTRACT(config,'$rule[0].type') from base_activity where type = 3select * from base_activity where type = 3 and type,JSON_EXTRACT(config,'$rule[0].type') = '13' 常用函数查询优化Explain详解id选择标识符 select_type表示查询的类型 table输出结果集的表 possible_key表示查询时，可能使用的索引 key表示实际使用的索引 key_len索引字段的长度 ref列与索引的比较 rows扫描出的行数(估算的行数) type如何从数据读取表：https://juejin.im/post/5eb3a976e51d454d9b12538b?utm_source=gold_browser_extension system：系统表，少量数据，往往不需要进行磁盘IO const：常量连接 eq_ref：主键索引(primary key)或者非空唯一索引(unique not null)等值扫描 ref：非主键非唯一索引等值扫描 range：范围扫描 index：索引树扫描 all： 检查所有的数据行 row：需要检查数据行事务隔离级别在MySQL的众多存储引擎中，只有InnoDB支持事务，所有这里说的事务隔离级别指的是InnoDB下的事务隔离级别。 读未提交：一个事务可以读取到另一个事务未提交的修改。这会带来脏读、幻读、不可重复读问题。（基本没用） 读已提交：一个事务只能读取另一个事务已经提交的修改。其避免了脏读，但仍然存在不可重复读和幻读问题。 可重复读：同一个事务中多次读取相同的数据返回的结果是一样的。其避免了脏读和不可重复读问题，但幻读依然存在。 串行化：事务串行执行。避免了以上所有问题。","categories":[],"tags":[]},{"title":"","slug":"Java8新特性-Lambda","date":"2018-05-04T07:22:10.386Z","updated":"2019-05-07T03:43:31.737Z","comments":true,"path":"Java8新特性-Lambda/","link":"","permalink":"http://liuyiyou.cn/Java8新特性-Lambda/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Java8新特性-总起","slug":"Java8新特性-总起","date":"2018-03-12T16:00:00.000Z","updated":"2019-05-08T19:51:38.389Z","comments":true,"path":"Java8新特性-总起/","link":"","permalink":"http://liuyiyou.cn/Java8新特性-总起/","excerpt":"","text":"","categories":[{"name":"java","slug":"java","permalink":"http://liuyiyou.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://liuyiyou.cn/tags/java/"}]},{"title":"Java8新特性-Stream","slug":"Java8新特性-Stream","date":"2018-03-12T16:00:00.000Z","updated":"2019-05-07T03:40:52.448Z","comments":true,"path":"Java8新特性-Stream/","link":"","permalink":"http://liuyiyou.cn/Java8新特性-Stream/","excerpt":"","text":"","categories":[{"name":"java","slug":"java","permalink":"http://liuyiyou.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://liuyiyou.cn/tags/java/"}]},{"title":"Java8新特性-函数式接口","slug":"Java8新特性-函数式接口","date":"2018-03-12T16:00:00.000Z","updated":"2019-05-08T19:51:32.927Z","comments":true,"path":"Java8新特性-函数式接口/","link":"","permalink":"http://liuyiyou.cn/Java8新特性-函数式接口/","excerpt":"","text":"Predicate断言 操作符 -&gt; Consumer","categories":[{"name":"java","slug":"java","permalink":"http://liuyiyou.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://liuyiyou.cn/tags/java/"}]},{"title":"Java8新特性-Optional","slug":"Java8新特性-Optional","date":"2018-03-12T16:00:00.000Z","updated":"2019-05-08T19:51:36.055Z","comments":true,"path":"Java8新特性-Optional/","link":"","permalink":"http://liuyiyou.cn/Java8新特性-Optional/","excerpt":"","text":"作用减少NPE 创建//创建一个空的OptionalOptional.empty//依据一个非空值创建Optional,如果是car==null 则会报NPEOptional&lt;Car&gt; optCar = Optional.of(car);//可接受null的Optional,如果是car==null 则返回一个空对象Optional&lt;Car&gt; optCar = Optional.ofNullable(car); 怎样获取值虽然Optional有提供一个```javaOptional&lt;Car&gt; optCar = Optional.ofNullable(car);if(optCar.isPresent)&#123; optCar.get();&#125; 则意义不是很大 1.1 使用map提取或者转换值","categories":[{"name":"java","slug":"java","permalink":"http://liuyiyou.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://liuyiyou.cn/tags/java/"}]},{"title":"SpringCloud学习-Sleuth","slug":"SpringCloud学习-Sleuth","date":"2017-11-16T16:00:00.000Z","updated":"2019-05-13T08:14:41.440Z","comments":true,"path":"SpringCloud学习-Sleuth/","link":"","permalink":"http://liuyiyou.cn/SpringCloud学习-Sleuth/","excerpt":"","text":"Sleuth是什么 耗时分析 可视化错误（Zipkin） 链路优化 一些术语Span：是Sleuth最基本的工作单位，微服务发起一次请求就是一个新的Span TraceAnnotation用于记录时间信息，包含如下 cs: 客户端发起，一个新的span开始 sr: 服务端接受，表示服务端接受请求并开始处理 ss: 服务端完成请求处理，应答信息被返回给客户端 cr: 客户端接受请求，Span结束 使用添加依赖","categories":[{"name":"spring-cloud","slug":"spring-cloud","permalink":"http://liuyiyou.cn/categories/spring-cloud/"}],"tags":[{"name":"spring-cloud","slug":"spring-cloud","permalink":"http://liuyiyou.cn/tags/spring-cloud/"}]},{"title":"SpringCloud学习-Zuul","slug":"SpringCloud学习-Zuul","date":"2017-11-13T16:00:00.000Z","updated":"2019-05-13T08:14:38.263Z","comments":true,"path":"SpringCloud学习-Zuul/","link":"","permalink":"http://liuyiyou.cn/SpringCloud学习-Zuul/","excerpt":"","text":"Zuul是什么Zuul是一个API网关服务，为所有客户端请求或其他消费提供统一的网关，通过该网关接入不同的微服务，并隐藏架构实现的细节 通过Zuul组件，可以完成以下功能 动态路由 监控与审查 身份认证与安全 压力测试 金丝雀、A/B测试 服务迁移 负载剪裁/限流 路由配置规则 默认与Eureka服务整合自动根据微服务ID进行映射 结合微服务ID通过自定义方式进行路由映射 直接使用静态URL路径的方式对微服务进行路由映射 添加全局路由器映射 通过自定义路由转换器，实现灵活的路由映射 默认与Eureka服务整合自动根据微服务ID进行映射如果有Eureka时，Zuul会自动为注册到服务器上的服务创建一个默认的规则：访问路径的前缀为serivceId配置的服务名称 http://[zuul路由服务器地址]/[serviceId]/[具体的服务的端点] http://localhost:8200/hello-service/base。 其中http://localhost:8200是Zuul的地址 hello-service是另外一个服务 /base是hello-service的一个方法 图：见印象笔记-》读书笔记-》Spring Cloud微服务实战 ——》 第六章 结合微服务ID通过自定义方式进行路由映射zuul.routes.serviceId=指定路径 zuul.routes.hello-service=/hello/** 直接使用静态URL路径的方式对微服务进行路由映射对于没有注册到Eureka服务器中的微服务，可以通过Zuul路由服务器中配置静态url来进行服务的路由映射 zuul.routes.python-sevice.path = /pythonservice/**zuul.routes.python-service.url = http://paythonServe:8888 注意点默认情况下,zuul不会将敏感的http首部,如(Cookie,Set-Cookie)和Authorization转发到下游服务,要让Zuul传播HTTP首部Authorization,需要在zuul服务网关的application.yml或者application.properties中,设置以下配置: zuul.sensitive-headers=&quot;Cookie&quot;, &quot;Set-Cookie&quot;, &quot;Authorization&quot;","categories":[{"name":"spring-cloud","slug":"spring-cloud","permalink":"http://liuyiyou.cn/categories/spring-cloud/"}],"tags":[{"name":"spring-cloud","slug":"spring-cloud","permalink":"http://liuyiyou.cn/tags/spring-cloud/"}]},{"title":"SpringCloud学习-Hystrix","slug":"SpringCloud学习-Hystrix","date":"2017-11-13T16:00:00.000Z","updated":"2019-02-09T14:09:24.473Z","comments":true,"path":"SpringCloud学习-Hystrix/","link":"","permalink":"http://liuyiyou.cn/SpringCloud学习-Hystrix/","excerpt":"","text":"Hystrix是什么Hystrix是用来做微服务容错保护的库，可以解决如下问题 对第三方接口/依赖服务潜在的调用失败提供保护和控制机制 在分布式系统中隔离资源，降低耦合，防止服务之间相互调用而导致级联失败 开始失败以及迅速恢复 设计理念 防止单个服务的故障而耗尽系统容器和线程资源 快速失败，而不是在队列中积压服务请求 提供服务降级（fallback）处理机制 使用隔离技术来隔离服务依赖之间的影响 通过近乎试试的监控和告警，几十发现系统中潜在的为 通过配置更改可以优化低延迟传播的恢复时间 开发下面通过一个demo来演Hystrix的开发 引入Hystrix依赖开启Hystrix支持启动和测试","categories":[{"name":"spring-cloud","slug":"spring-cloud","permalink":"http://liuyiyou.cn/categories/spring-cloud/"}],"tags":[{"name":"spring-cloud","slug":"spring-cloud","permalink":"http://liuyiyou.cn/tags/spring-cloud/"}]},{"title":"SpringCloud学习-Feigh","slug":"SpringCloud学习-Feigh","date":"2017-11-12T16:00:00.000Z","updated":"2019-12-07T17:14:45.481Z","comments":true,"path":"SpringCloud学习-Feigh/","link":"","permalink":"http://liuyiyou.cn/SpringCloud学习-Feigh/","excerpt":"","text":"目的 学会使用Feigh声明式服务调用 在RPC框架中，服务调用一般是服务的暴露接口，并提供客户端API，客户端在添加依赖后，即可像本地方法一样调用远程服务，SpringCloud也提供了类似需求，而在此之前，使用的是RestTemplate调用，所需的参数是在url中进行拼接，如果参数过多的时候不好拼接，另外，不容易进行管理，更好的替代方案是使用Feigh Feigh是一个声明式的web service客户端，可以像调用本地方法一样调用远程方法 Feigh整合了RIbbon和Hystrix 特性 可插拔注解支持，包括Feigh注解和Jax-RS注解 支持可插拔的Http编码器和解码器 支持Hystrix和它的回退功能 支持Ribbon负载均衡 支持Http请求和响应的压缩处理 准备工作需要4个项目： eureka-server：服务注册中心 user-service-feigh-api：服务API，客户端依赖，user-service-feigh-impl：服务实现放 ，user-service-client：服务消费方 提供一个供服务方和消费方共用的api接口 user-service-feigh-api 提供一个增删改查的用户服务 user-service-feigh-impl 体统一个调用user-srvice的客户端 user-service-client Eureka服务中心搭建参考SpringCloud学习-Eureka 服务提供方新建项目：user-service-api 该项目仅仅提供服务API，并不需要启动，服务提供方和服务消费方都依赖该项目，实际情况下，该项目应该写在user-service-feigh-impl中，通过不同的打包方式将该项目打包出来，由各个服务方调用 添加依赖&lt;!--1.x的 不使用了--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 提供API只有接口，没有实现 @FeignClient(\"USER-SERVICE\")public interface UserService &#123; @RequestMapping(\"add-user\") String addUser(); @RequestMapping(\"list-user\") List&lt;User&gt; listUser(); @RequestMapping(\"delete-user\") boolean deleteUser(); @RequestMapping(\"update-user\") String updateUser();&#125;@Datapublic class User &#123; private int id; private String name; private int age;&#125; 启动不需要启动，由user-service-feigh-impl和user-service依赖 服务实现方新建项目：user-service-feigh-impl 添加依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;cn.liuyiyou.springcloud&lt;/groupId&gt; &lt;artifactId&gt;user-service-feigh-api&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 配置文件#服务命名spring.application.name=user-service#指定服务注册中心地址eureka.client.service-url.defaultZone=http://localhost:1111/eurekaserver.port=8080 启动类@EnableDiscoveryClient@SpringBootApplicationpublic class UserServiceFeighApiApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UserServiceFeighApiApplication.class, args); &#125;&#125; 服务实现类注意： 实现了UserService接口，确保声明的服务都有其实现方法 包所在的名字是service，但是写的方式好像是controller，这是因为采用的是http方式进行调用 package cn.liuyiou.cloud.service;import cn.liuyiou.cloud.model.User;import com.google.common.collect.Lists;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;/** * 该注解必须是 @RestController 不能是@Service */@RestControllerpublic class UserServiceImpl implements UserService &#123; &lt;!-- @RequestMapping(\"add-user\") --&gt; @Override public String addUser() &#123; return \"add User Has Been Called\"; &#125; &lt;!-- @RequestMapping(\"list-user\") --&gt; @Override public List&lt;User&gt; listUser() &#123; return Lists.newArrayList(new User() &#123;&#123; setId(1); setAge(18); setName(\"lyy\"); &#125;&#125;, new User() &#123;&#123; setId(2); setAge(18); setName(\"yi\"); &#125;&#125;, new User() &#123;&#123; setId(1); setAge(18); setName(\"you\"); &#125;&#125;); &#125; &lt;!-- @RequestMapping(\"delete-user\") --&gt; @Override public boolean deleteUser() &#123; return true; &#125; &lt;!-- @RequestMapping(\"update-user\") --&gt; @Override public String updateUser() &#123; return \"update User Has Been Called\"; &#125;&#125; 启动观察是否注册到服务中心中了 服务调用方新建项目user-service-client 添加依赖因为只是调用方，该依赖可以不添加 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件因为只是调用方，该配置可以不添加 #服务命名spring.application.name=hello-service#指定服务注册中心地址eureka.client.service-url.defaultZone=http://localhost:1111/eurekaserver.port=10000#需要启动eureka-server后启动,再看 http://localhost:1111/ 会发现hello-service已经注册到服务中心中去了 添加注释因为只是调用方，该@EnableDiscoveryClient可以不添加 注意： 因为UserService是单独编译一个jar包，所以在使用@EnableFeignClients注解时需要指定basePackages的值,否则报错:Consider defining a bean of type ‘cn.liuyiou.cloud.service.api.Service’ in your configuration. /** * 因为UserService是单独编译一个jar包，所以在使用@EnableFeignClients注解时需要指定basePackages的值,否则报错 * Consider defining a bean of type 'cn.liuyiou.cloud.service.api.Service' in your configuration. */@EnableFeignClients(basePackages = \"cn.liuyiou.cloud.service.api\")@SpringBootApplication@EnableDiscoveryClientpublic class UserServiceClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UserServiceClientApplication.class, args); &#125;&#125; 调用服务package cn.liuyiou.cloud.controller;import cn.liuyiou.cloud.model.User;import cn.liuyiou.cloud.service.UserService;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.PostConstruct;import java.util.List;@RestControllerpublic class UserController &#123; private Logger logger = LoggerFactory.getLogger(UserController.class); @Autowired private UserService userService; public UserController() &#123; logger.info(\"userservice In Construct &#123;&#125;\", userService); &#125; @PostConstruct public void printService()&#123; logger.info(\"userservice In PostConstruct::&#123;&#125;\", userService); &#125; @RequestMapping(\"/add-user\") public String saveUser() &#123; return userService.addUser(); &#125; @RequestMapping(\"/list-user\") public List&lt;User&gt; getUser() &#123; logger.info(\"userservice In Method ::&#123;&#125;\", userService); List&lt;User&gt; userList = userService.listUser(); return userList; &#125; @RequestMapping(\"/edit-user\") public String editUser() &#123; return userService.updateUser(); &#125; @RequestMapping(\"/delete-user\") public Boolean deleteUser() &#123; return userService.deleteUser(); &#125;&#125; 启动 userservice In Construct null userservice In PostConstruct::HardCodedTarget(type=UserService, name=USER-SERVICE, url=http://USER-SERVICE) userservice In Method ::HardCodedTarget(type=UserService, name=USER-SERVICE, url=http://USER-SERVICE) 访问 ： http://localhost:8081/list-user [&#123;\"id\":1,\"name\":\"lyy\",\"age\":18&#125;,&#123;\"id\":2,\"name\":\"yi\",\"age\":18&#125;,&#123;\"id\":1,\"name\":\"you\",\"age\":18&#125;] API和IMP合二为一具体的目录规范需要自己定义 &lt;groupId&gt;cn.liuyiyou.springcloud&lt;/groupId&gt; &lt;artifactId&gt;user-service-api&lt;/artifactId&gt; &lt;version&gt;0.0.2-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;user-service-api&lt;/name&gt;&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;configuration&gt; &lt;includes&gt; &lt;include&gt;cn/liuyiyou/cloud/model/**/*.class&lt;/include&gt; &lt;include&gt;cn/liuyiyou/cloud/service/api/**/*.class&lt;/include&gt; &lt;/includes&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;/plugins&gt; 客户端依赖修改成 0.0.2 总结对于微服务来说，除了对其他服务提供服务之外，同时也对web层提供服务，这里有一点容易混淆，在同一个项目中的控制层如何确定是通过 声明式服务调用还是直接调用 @EnableFeignClientsProductController : produService::HardCodedTarget(type=IProductService, name=SERVICE-PRODUCT, url=http://SERVICE-PRODUCT)不加ProductController : produService::com.iba.service.product.service.ProductService@19f4620b 深入Feigh来自《Spring Cloud 微服务架构开发实战》 Feigh参数绑定Feigh中的继承Feigh与Swagger的冲突版本太低 参考资料Spring Cloud入门教程(三)：声明式服务调用(Feign)Spring Cloud 声明式服务调用 Feign","categories":[{"name":"spring-cloud","slug":"spring-cloud","permalink":"http://liuyiyou.cn/categories/spring-cloud/"}],"tags":[{"name":"spring-cloud","slug":"spring-cloud","permalink":"http://liuyiyou.cn/tags/spring-cloud/"}]},{"title":"SpringCloud学习-Ribbon","slug":"SpringCloud学习-Ribbon","date":"2017-11-11T16:00:00.000Z","updated":"2019-02-08T14:00:20.041Z","comments":true,"path":"SpringCloud学习-Ribbon/","link":"","permalink":"http://liuyiyou.cn/SpringCloud学习-Ribbon/","excerpt":"","text":"引入Ribbon&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 上面这个包含了Ribbon，如果不想引入这么多，可以只引入Ribbon&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;&lt;/dependency&gt; 开启负载均衡@EnableDiscoveryClient@SpringBootApplicationpublic class RibbonApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RibbonApplication.class, args); &#125; @Bean /** * 开启客户端负载均衡 */ @LoadBalanced public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125;@RestControllerpublic class RibbonConsumerController &#123; @Autowired private RestTemplate restTemplate; //并没有指定服务端口，只是指定了服务名称即可发生调用 @GetMapping(\"/ribbon\") public String helloRibbon() &#123; return restTemplate.getForEntity(\"http://HELLO-SERVICE/base\", String.class).getBody(); &#125;&#125; 实现原理 Ribbon首先根据其所在的zone优先选择一个负载较少的Eureka服务器 定期从Eureka服务器更新，并过滤服务实例列表 根据指定的负载均衡策略，从可用的服务实例选择一个 调用该地址，通过Rest客户端进行服务调用 扩展知识Ribbon提供了6个组件 服务器列表（ServerList）服务器列表就是客户端负载均衡所使用的各服务实例列表。Ribbon在实现上支持下面3种服务器列表方式 静态服务器列表：可以通过Ribbon中的BaseLoadBanlancer#setServersList()方法进行设置 基于配置的服务器列表：需要在项目中通过配置文件&lt;服务名称&gt;.ribbon.listOfServers属性进行设置。代码如下: # 这里为用户服务配置了3个服务器列表userservice.ribbon.listOfServers=http://127.0.0.1:100001,http://127.0.0.1:100002,http://127.0.0.1:100003 基于服务发现的服务列表 服务器列表过滤器（ServerListFilter） 服务实例存货探测（IPing） 负载均衡策略（IRule） 负载均衡器（ILoadBanlace） 服务调用器（RestClient）","categories":[{"name":"spring-cloud","slug":"spring-cloud","permalink":"http://liuyiyou.cn/categories/spring-cloud/"}],"tags":[{"name":"spring-cloud","slug":"spring-cloud","permalink":"http://liuyiyou.cn/tags/spring-cloud/"}]},{"title":"SpringCloud学习-Eureka","slug":"SpringCloud学习-Eureka","date":"2017-11-10T16:00:00.000Z","updated":"2019-02-08T13:10:51.365Z","comments":true,"path":"SpringCloud学习-Eureka/","link":"","permalink":"http://liuyiyou.cn/SpringCloud学习-Eureka/","excerpt":"","text":"Eureka是什么，SpringCloud用Eureka来干什么等等相关概念就不细说了，网上有大把大把的解释，甚至下面的文章都不需要看，因为网上也有大把大把的列子，为了省去搜索的时间，可以参考：Spring资料大全 中的SpringCloud相关文档。本文的目的只是自己记录一下 目的 Eureka服务中心搭建 其他服务注册到Eureka服务中心 Eureka服务中心高可用 Eureka服务中心相关配置详解 需要三个项目： eureka-server：服务注册中心，base-service-producer：服务提供方，hello-service：服务调用方（也可以是另外一个服务） Eureka服务中心搭建新建项目：eureka-server添加依赖&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;properties&gt; &lt;spring-cloud.version&gt;Finchley.SR2&lt;/spring-cloud.version&gt; &lt;maven.skip.test&gt;true&lt;/maven.skip.test&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 添加注解@EnableEurekaServer 和 @EnableDiscoveryClient 都能开启服务注册效果，不过前者只针对Eureka的服务注册，来自于SCN，而后者是来自spring-cloud-commons，能用于其他服务注册 /** * 该注解启动一个服务注册中心给其他应用进行对话 *///@EnableEurekaServer/** * 更加通用，如果使用了Consoule也能进行发现 */@EnableDiscoveryClient@SpringBootApplicationpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; 增加配置eureka: instance: hostname: localhost client: service-url: defaultZoon: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka fetch-registry: false #表示启动后，不需要同步已注册的服务注册列表数据到本地 register-with-eureka: false #作为服务端不需要注册自己 启动启动后,打开 http://localhost:4001/ 如果出息正常界面表示服务注册中心已经正常启动 其他服务注册到Eureka服务中心新建项目：hello-service添加依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-commons&lt;/artifactId&gt;&lt;/dependency&gt; &lt;!--这个包括上面的，2.x和1.x包名改动还挺大的--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 安全配置文件#服务命名spring.application.name=hello-service#指定服务注册中心地址eureka.client.service-url.defaultZone=http://localhost:4001/eurekaserver.port=10000#需要启动eureka-server后启动,再看 http://localhost:1111/ 会发现hello-service已经注册到服务中心中去了 添加注解因为只是调用方，该@EnableDiscoveryClient可以不添加 @EnableDiscoveryClient@SpringBootApplicationpublic class HelloServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HelloServiceApplication.class, args); &#125;&#125; 调用服务import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cloud.client.ServiceInstance;import org.springframework.cloud.client.discovery.DiscoveryClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @Autowired private DiscoveryClient discoveryClient; @GetMapping(\"/hello\") public String index() &#123; return \"Hello Spring Cloud\"; &#125; @GetMapping(\"/base\") public String baseSerivce() &#123; List&lt;String&gt; services = discoveryClient.getServices(); if (!services.isEmpty()) &#123; ServiceInstance instance = discoveryClient.getInstances(services.get(0)).get(0); String url = \"http://\" + instance.getHost() + \":\" + instance.getPort() + \"/\" + instance.getServiceId(); return url; &#125; else &#123; return \"no service\"; &#125; &#125;&#125; 启动http://localhost:10000/base 刚开始启动，会返回no service， 一个服务实例注册到Eureka大概是30秒左右，Eureka要求服务提供者必须发送3次心跳后才认为该服务实例已经就绪。 30秒后，就可以看到 http://192.168.1.101:10000/HELLO-SERVICE 同时，Eureka服务注册中心服务列表中能看到hello-service已经注册到服务注册中心中去了 Eureka安全服务端配置像上面那样Eureka服务注册中心是可以直接访问的，这样任何人只要知道ip地址就能登陆，如果需要用户名和密码访问，则application.yml做如下改动 根据官方文档配置如下，好像并没有起作用 eureka: username: lyy password: 123456 instance: hostname: localhost status-page-url: $&#123;server.servlet.path&#125;/info health-check-url-path: $&#123;server.servlet.path&#125;/health client: service-url: defaultZoon: http://$&#123;eureka.username&#125;:$&#123;eureka.password&#125;@$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka fetch-registry: false #表示启动后，不需要同步已注册的服务注册列表数据到本地 register-with-eureka: false #作为服务端不需要注册自己 同时，在pom中增加&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 还是没有起作用。 最后这样配置： eureka: instance: hostname: localhost status-page-url: $&#123;server.servlet.path&#125;/info health-check-url-path: $&#123;server.servlet.path&#125;/health client: service-url: defaultZoon: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka fetch-registry: false #表示启动后，不需要同步已注册的服务注册列表数据到本地 register-with-eureka: false #作为服务端不需要注册自己spring: security: user: name: lyy password: 123456 虽然起作用了，但是已经与Eureka无关了。 为了让客户端能够注册到Eureka—Server，还需要加上如下类： @EnableWebSecurityclass WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.csrf().ignoringAntMatchers(\"/eureka/**\"); super.configure(http); &#125;&#125; 原因如下： You can secure your Eureka server simply by adding Spring Security to your server’s classpath via spring-boot-starter-security. By default when Spring Security is on the classpath it will require that a valid CSRF token be sent with every request to the app. Eureka clients will not generally possess a valid cross site request forgery (CSRF) token you will need to disable this requirement for the /eureka/** endpoints. 客户端另外，其他服务注册到该服务注册中心时，需要将用户名和密码带上 eureka.client.service-url.defaultZone=http://lyy:123456@localhost:4001/eureka Eureka服务中心高可用application-peer1.propertiesspring.application.name=high-eureka-serviceserver.port=1111eureka.instance.hostname=peer1eureka.client.service-url.defaultZone=http://peer2:1112/eureka/#需要在/etc/hosts中 加上 ip到host的映射 127.0.0.1 peer2#在target 中运行#java -jar high-eureka-server-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer1#java -jar high-eureka-server-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer2#后访问 http://localhost:1112/ http://localhost:1111/ 可用看到将两个注册中心都当做服务注册到了注册中心中 application-peer2.propertiesspring.application.name=high-eureka-serviceserver.port=1112eureka.instance.hostname=peer2eureka.client.service-url.defaultZone=http://peer1:1111/eureka/#需要在/etc/hosts中 加上 ip到host的映射 127.0.0.1 peer1 启动访问 http://localhost:1111/访问 http://localhost:1112/ 两者互相注册 Eureka服务中心相关配置详解","categories":[{"name":"spring-cloud","slug":"spring-cloud","permalink":"http://liuyiyou.cn/categories/spring-cloud/"}],"tags":[{"name":"spring-cloud","slug":"spring-cloud","permalink":"http://liuyiyou.cn/tags/spring-cloud/"}]},{"title":"SpringBoot学习-集成MyBatis-Plus分布式事务","slug":"SpringBoot学习-集成MyBatis-Plus分布式事务","date":"2017-09-17T16:00:00.000Z","updated":"2019-04-17T13:47:17.785Z","comments":true,"path":"SpringBoot学习-集成MyBatis-Plus分布式事务/","link":"","permalink":"http://liuyiyou.cn/SpringBoot学习-集成MyBatis-Plus分布式事务/","excerpt":"","text":"和SpringBoot学习-分布式事务 类似，差别在于 mybatis-plus使用的是自己的SqlSessionFactoryBean，所以在设置SqlSessionFactory的时候，要初始化mybatis-plus的MybatisSqlSessionFactoryBean mybatis-plus的一些插件（比如分页、性能分析插件）需要注入 application.yml##分布式事务spring: jta: atomikos: datasource: system: xa-data-source-class-name: com.mysql.jdbc.jdbc2.optional.MysqlXADataSource unique-resource-name: systemDataSource max-pool-size: 5 test-query: select 1 pool-size: 2 xa-properties: user: root password: root url: jdbc:mysql://192.168.0.200:3306/xx base: xa-data-source-class-name: com.mysql.jdbc.jdbc2.optional.MysqlXADataSource unique-resource-name: baseDataSource max-pool-size: 5 test-query: select 1 pool-size: 2 xa-properties: user: root password: root url: jdbc:mysql://192.168.0.200:3306/base prod: xa-data-source-class-name: com.mysql.jdbc.jdbc2.optional.MysqlXADataSource unique-resource-name: prodDataSource max-pool-size: 5 test-query: select 1 pool-size: 2 xa-properties: user: root password: root url: jdbc:mysql://192.168.0.200:3306/prod enabled: true javapublic class AbstractDataSourceConfig { @Autowired private ObjectProvider&lt;Interceptor[]&gt; interceptorsProvider; @Autowired private ApplicationContext applicationContext; /** * 统一设置mybatis-plus相关属性 */ public SqlSessionFactory setSqlsessionFactory(DataSource dataSource, String mapperLocation) throws Exception { //mybatis-plus自己的SqlSessionFactoryBean final MybatisSqlSessionFactoryBean factory = new MybatisSqlSessionFactoryBean(); factory.setDataSource(dataSource); factory.setMapperLocations(new PathMatchingResourcePatternResolver() .getResources(mapperLocation)); factory.setVfs(SpringBootVFS.class); GlobalConfig globalConfig = new GlobalConfig(); globalConfig.setMetaObjectHandler(new MetaObjectHandlerConfig()); //注入sql注入器 if (this.applicationContext.getBeanNamesForType(ISqlInjector.class, false, false).length &gt; 0) { ISqlInjector iSqlInjector = this.applicationContext.getBean(ISqlInjector.class); globalConfig.setSqlInjector(iSqlInjector); } factory.setGlobalConfig(globalConfig); factory.setPlugins(interceptorsProvider.getIfAvailable()); return factory.getObject(); } } @Configuration @MapperScan(basePackages = BaseDataSourceConfig.BASE_PACKAGE, sqlSessionFactoryRef = \"baseSqlSessionFactory\") public class BaseDataSourceConfig extends AbstractDataSourceConfig { static final String BASE_PACKAGE = \"cn.liuyiyou.shop.base.mapper\"; static final String MAPPER_LOCATION = \"classpath:/mapper/base/*.xml\"; @Bean(name = \"baseDataSource\") @ConfigurationProperties(prefix = \"spring.jta.atomikos.datasource.base\") public DataSource baseDataSource() { return new AtomikosDataSourceBean(); } @Bean(name = \"baseSqlSessionFactory\") public SqlSessionFactory baseSqlSessionFactory(@Qualifier(\"baseDataSource\") DataSource dataSource) throws Exception { return super.setSqlsessionFactory(dataSource, MAPPER_LOCATION); } } 另外两个DataSourceConfig和BaseDataSourceConfig类似","categories":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://liuyiyou.cn/categories/spring-boot/"}],"tags":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://liuyiyou.cn/tags/spring-boot/"}]},{"title":"SpringBoot学习-集成MyBatis","slug":"SpringBoot学习-集成MyBatis","date":"2017-09-16T16:00:00.000Z","updated":"2018-01-23T06:39:58.827Z","comments":true,"path":"SpringBoot学习-集成MyBatis/","link":"","permalink":"http://liuyiyou.cn/SpringBoot学习-集成MyBatis/","excerpt":"","text":"之前在Spring集成MyBatis的时候需要将相关依赖加到pom中，然后在spring-config.xml中配置SqlSessionFactoryBean， 里面需要指定mybatis配置文件位置等，还需要配置扫描接口MapperScannerConfigurer现在只需要一行代码搞定 @MapperScan(&quot;cn.liuyiyou.sprongboot.mapper&quot;) 之前的配置 &lt;!-- ======================================================================== --&gt;&lt;!-- MyBatis SQL定义。管理MyBatis的Sqlsession --&gt;&lt;!-- ======================================================================== --&gt;&lt;!-- 创建SqlSessionFactory，同时指定数据源 --&gt;&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;!-- 别名，如果在同一个基础包下有同名的，会报错。所以在这里需要精确一点 --&gt; &lt;property name=\"typeAliasesPackage\" value=\"cn.liuyiyou.mybatis.domain.chapter11\" /&gt; &lt;!-- mybatis配置文件位置 --&gt; &lt;property name=\"configLocation\" value=\"classpath:chapter11/mybatis-config.xml\" /&gt; &lt;!-- 映射文件位置 --&gt; &lt;property name=\"mapperLocations\" value=\"classpath*:mapper/chapter11/**/*.xml\" /&gt; &lt;property name=\"typeAliases\" value=\"org.springframework.util.LinkedCaseInsensitiveMap\" /&gt;&lt;/bean&gt;&lt;!-- ======================================================================== --&gt;&lt;!-- 扫描Mybatis接口包定义。 --&gt;&lt;!-- ======================================================================== --&gt;&lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"cn.liuyiyou.mybatis.mapper.chapter11\" /&gt;&lt;/bean&gt; 最简配置@MapperScan(&quot;cn.liuyiyou.sprongboot.mapper&quot;)一行代码搞定 需要注意的是，该注释并不是mybatis-spring-boot-starter提供的，而是mybatis-spring来提供的，也就是说，哪怕不用springboot，也是有该功能的，只是在spring-boot之前，一般都是基于xml配置的。 另外，如果不是基于spring-boot，需要定义数据源、事务管理器等，而集成spring-boot之后，不在需要自己管理这些，而是由MybatisAutoConfiguration 来进行自动配置 添加依赖&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; java代码 @Configuration @MapperScan(\"org.mybatis.spring.sample.mapper\") public class AppConfig &#123; @Bean public DataSource dataSource() &#123; return new EmbeddedDatabaseBuilder() .addScript(\"schema.sql\") .build(); &#125; @Bean public DataSourceTransactionManager transactionManager() &#123; return new DataSourceTransactionManager(dataSource()); &#125; @Bean public SqlSessionFactory sqlSessionFactory() throws Exception &#123; SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean(); sessionFactory.setDataSource(dataSource()); return sessionFactory.getObject(); &#125; &#125;``` ## aplication.properties这个虽然与mybatis无关，但是不能去掉，毕竟mybatis就是一个orm框架 spring.datasource.url=jdbc:mysql://localhost:3306/blog?useUnicode=true&amp;characterEncoding=utf-8&amp;rewriteBatchedStatements=true&amp;zeroDateTimeBehavior=convertToNullspring.datasource.username=rootspring.datasource.password=123456spring.datasource.driverClassName=com.mysql.jdbc.Driver `","categories":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://liuyiyou.cn/categories/spring-boot/"}],"tags":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://liuyiyou.cn/tags/spring-boot/"}]},{"title":"SpringBoot学习-分布式事务","slug":"SpringBoot学习-分布式事物","date":"2017-09-15T16:00:00.000Z","updated":"2019-01-30T01:56:16.050Z","comments":true,"path":"SpringBoot学习-分布式事物/","link":"","permalink":"http://liuyiyou.cn/SpringBoot学习-分布式事物/","excerpt":"","text":"最简配置pom&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; application.propertiesspring.jta.enabled=truespring.jta.atomikos.service=com.atomikos.icatch.standalone.UserTransactionServiceFactoryspring.jta.atomikos.datasource.one.xa-data-source-class-name=com.mysql.jdbc.jdbc2.optional.MysqlXADataSourcespring.jta.atomikos.datasource.one.unique-resource-name=dataSourceOnespring.jta.atomikos.datasource.one.max-pool-size=5spring.jta.atomikos.datasource.one.xa-properties.user=rootspring.jta.atomikos.datasource.one.xa-properties.password=123456spring.jta.atomikos.datasource.one.xa-properties.url=jdbc:mysql://localhost:3306/blog?useUnicode=true&amp;characterEncoding=utf-8&amp;rewriteBatchedStatements=true&amp;zeroDateTimeBehavior=convertToNullspring.jta.atomikos.datasource.two.unique-resource-name=dataSourceTwospring.jta.atomikos.datasource.two.max-pool-size=5spring.jta.atomikos.datasource.two.xa-properties.user=rootspring.jta.atomikos.datasource.two.xa-properties.password=123456spring.jta.atomikos.datasource.two.xa-properties.url=jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;rewriteBatchedStatements=true&amp;zeroDateTimeBehavior=convertToNullspring.jta.atomikos.datasource.two.xa-data-source-class-name=com.mysql.jdbc.jdbc2.optional.MysqlXADataSourcespring.jta.atomikos.datasource.three.unique-resource-name=dataSourceThreespring.jta.atomikos.datasource.three.max-pool-size=5spring.jta.atomikos.datasource.three.xa-properties.user=ibalifespring.jta.atomikos.datasource.three.xa-properties.password=ibalifespring.jta.atomikos.datasource.three.xa-properties.url=jdbc:mysql://192.168.0.200:3306/ibalife_user?useUnicode=true&amp;characterEncoding=utf-8&amp;rewriteBatchedStatements=true&amp;zeroDateTimeBehavior=convertToNullspring.jta.atomikos.datasource.three.xa-data-source-class-name=com.mysql.jdbc.jdbc2.optional.MysqlXADataSource java /** * 数据源1 ,这样写是为了每个DataSource能依赖他自己的sqlsessionFactory */ @Configuration @MapperScan(basePackages = BlogDataSourceConfig.PACKAGE, sqlSessionFactoryRef = \"blogSqlSessionFactory\") class BlogDataSourceConfig { static final String PACKAGE = \"com.ibalife.message.mapper.blog\"; @Bean @Primary @ConfigurationProperties(prefix = \"spring.jta.atomikos.datasource.one\") public DataSource dataSourceOne() { return new AtomikosDataSourceBean(); } @Bean(name = \"blogSqlSessionFactory\") @Primary public SqlSessionFactory clusterSqlSessionFactory(@Qualifier(\"dataSourceOne\") DataSource clusterDataSource) throws Exception { final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean(); sessionFactory.setDataSource(clusterDataSource); sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver() .getResources(\"classpath:mapper/blog/*.xml\")); return sessionFactory.getObject(); } } /** * 数据源2 */ @Configuration @MapperScan(basePackages = TestDataSourceConfig.PACKAGE, sqlSessionFactoryRef = \"testSqlSessionFactory\") public class TestDataSourceConfig { static final String PACKAGE = \"com.ibalife.message.mapper.test\"; @Bean @ConfigurationProperties(prefix = \"spring.jta.atomikos.datasource.two\") public DataSource dataSourceTwo() { return new AtomikosDataSourceBean(); } @Bean(name = \"testSqlSessionFactory\") public SqlSessionFactory testSqlSessionFactory(@Qualifier(\"dataSourceTwo\") DataSource clusterDataSource) throws Exception { final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean(); sessionFactory.setDataSource(clusterDataSource); sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver() .getResources(\"classpath:mapper/test/*.xml\")); return sessionFactory.getObject(); } } /** * 数据源3 ,在另外一台机器上 */ @Configuration @MapperScan(basePackages = IbaDataSourceConfig.PACKAGE, sqlSessionFactoryRef = \"ibaSqlSessionFactory\") public class IbaDataSourceConfig { static final String PACKAGE = \"com.ibalife.message.mapper.iba\"; @Bean @ConfigurationProperties(prefix = \"spring.jta.atomikos.datasource.three\") public DataSource dataSourceThree() { return new AtomikosDataSourceBean(); } @Bean(name = \"ibaSqlSessionFactory\") public SqlSessionFactory testSqlSessionFactory(@Qualifier(\"dataSourceThree\") DataSource clusterDataSource) throws Exception { final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean(); sessionFactory.setDataSource(clusterDataSource); sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver() .getResources(\"classpath:mapper/ibalife/*.xml\")); return sessionFactory.getObject(); } }","categories":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://liuyiyou.cn/categories/spring-boot/"}],"tags":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://liuyiyou.cn/tags/spring-boot/"}]},{"title":"SpringBoot学习-集成JDBC","slug":"SpringBoot学习-集成JDBC","date":"2017-09-14T16:00:00.000Z","updated":"2019-04-17T13:46:07.637Z","comments":true,"path":"SpringBoot学习-集成JDBC/","link":"","permalink":"http://liuyiyou.cn/SpringBoot学习-集成JDBC/","excerpt":"","text":"内容 默认配置 自定义配置 集成第三方数据源 最简配置pom&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; aplication.properties这个必须配置，不然会报错 spring.datasource.url=jdbc:mysql://localhost:3306/blog?useUnicode=true&amp;characterEncoding=utf-8&amp;rewriteBatchedStatements=true&amp;zeroDateTimeBehavior=convertToNullspring.datasource.username=rootspring.datasource.password=123456spring.datasource.driverClassName=com.mysql.jdbc.Driver Druidhttps://github.com/alibaba/druid/tree/master/druid-spring-boot-starter 自定义数据源@Configurationpublic class DataSourceConfig &#123; @Value(\"$&#123;spring.datasource.url&#125;\") private String url; @Value(\"$&#123;spring.datasource.username&#125;\") private String username; @Value(\"$&#123;spring.datasource.password&#125;\") private String password; //..... @Bean public DataSource dataSource() &#123; DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setUrl(url); druidDataSource.setUsername(username); druidDataSource.setPassword(password); //.... return druidDataSource; &#125;&#125; 也可以使用这种 @Configurationpublic class SimpleDataSourceConfig &#123; @Bean public DataSource dataSource(DataSourceProperties properties)&#123; DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setPassword(properties.getPassword()); druidDataSource.setUsername(properties.getUsername()); druidDataSource.setUrl(properties.getUrl()); druidDataSource.setDriverClassName(properties.getDriverClassName()); return druidDataSource; &#125;&#125;","categories":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://liuyiyou.cn/categories/spring-boot/"}],"tags":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://liuyiyou.cn/tags/spring-boot/"}]},{"title":"SpringBoot学习-日志处理","slug":"SpringBoot学习-日志处理","date":"2017-09-13T16:00:00.000Z","updated":"2018-01-23T06:35:46.576Z","comments":true,"path":"SpringBoot学习-日志处理/","link":"","permalink":"http://liuyiyou.cn/SpringBoot学习-日志处理/","excerpt":"","text":"需整理 在resources目录下加入logback.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration scan=\"true\" scanPeriod=\"60 seconds\"&gt; &lt;appender name=\"stdout\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-M-d HH:mm:ss&#125; %t %p %m%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=\"springboot\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!-- &lt;Encoding&gt;UTF-8&lt;/Encoding&gt; --&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;FileNamePattern&gt;logs/logback/springboot_%d&#123;yyyy-M-d&#125;.log &lt;/FileNamePattern&gt; &lt;MaxHistory&gt;10&lt;/MaxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-M-d HH:mm:ss&#125; %t %p %m%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=\"smile\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;FileNamePattern&gt;logs/logback/smile_%d&#123;yyyy-M-d&#125;.log &lt;/FileNamePattern&gt; &lt;MaxHistory&gt;10&lt;/MaxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-M-d HH:mm:ss&#125; %t %p %m%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;logger name=\"org.springframework.boot\" level=\"debug\" additivity=\"false\"&gt; &lt;appender-ref ref=\"springboot\"/&gt; &lt;/logger&gt; &lt;!-- name包必须能够扫描到所以类，包括启动类 --&gt; &lt;logger name=\"com.smile\" level=\"debug\" additivity=\"false\"&gt; &lt;appender-ref ref=\"smile\"/&gt; &lt;/logger&gt; &lt;root level=\"info\"&gt; &lt;appender-ref ref=\"stdout\"/&gt; &lt;/root&gt;&lt;/configuration&gt; aplication.properties日志级别 logging.level.com.ibalife.message.mapper.mapper=debuglogging.level.org.springframework.jdbc.datasource=debug 参考文章http://blog.csdn.net/zhuyucheng123/article/details/51803852","categories":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://liuyiyou.cn/categories/spring-boot/"}],"tags":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://liuyiyou.cn/tags/spring-boot/"}]},{"title":"SpringBoot学习-异常处理","slug":"SpringBoot学习-异常处理","date":"2017-09-12T16:00:00.000Z","updated":"2019-04-17T13:45:17.980Z","comments":true,"path":"SpringBoot学习-异常处理/","link":"","permalink":"http://liuyiyou.cn/SpringBoot学习-异常处理/","excerpt":"","text":"常规异常统一异常package cn.liuyiyou.shop.common.exception;import cn.liuyiyou.shop.common.response.Response;import cn.liuyiyou.shop.common.response.Result;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import lombok.extern.slf4j.Slf4j;import org.springframework.context.annotation.Configuration;import org.springframework.jdbc.BadSqlGrammarException;import org.springframework.validation.ObjectError;import org.springframework.web.bind.MethodArgumentNotValidException;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.RestControllerAdvice;import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;import java.nio.file.AccessDeniedException;import java.util.List;/** * 全局异常处理 * * @author: liuyiyou * @date: 2017/11/17 * Time: 下午1:55 */@RestControllerAdvice@Slf4j@Configurationpublic class GlobalExceptionHandler &#123; @ExceptionHandler(DefaultException.class) public Result defaultExceptionHandler(Exception e) &#123; log.error(\"404异常\", e); String message = e.getMessage(); JSONObject erroInfo = JSON.parseObject(message); int status = erroInfo.getInteger(\"status\"); switch (status) &#123; case 404: return Response.fail(erroInfo.getInteger(\"status\"), \"找不到页面\"); case 403: return Response.fail(erroInfo.getInteger(\"status\"), \"没有权限访问\"); case 405: return Response.fail(erroInfo.getInteger(\"status\"), \"不支持的访问方法\"); &#125; return Response.fail(erroInfo.getInteger(\"status\"), e.getMessage()); &#125; @ExceptionHandler(AccessDeniedException.class) public Result accessDeniedExceptionHandler(AccessDeniedException e) &#123; log.error(\"权限异常\", e); return Response.fail(403, \"没有权限访问\", e.getMessage()); &#125; @ExceptionHandler(RuntimeException.class) public Result defaultErrorHandler(Exception e) &#123; log.error(\"系统异常\", e); return Response.fail(500, \"系统出问题了\", e.getMessage()); &#125; @ExceptionHandler(BusiException.class) public Result busiExceptionHandler(Exception e) &#123; log.debug(\"业务异常\", e); return Response.fail(500, e.getMessage()); &#125; @ExceptionHandler(BadSqlGrammarException.class) public Result BadSqlGrammarExceptionHandler(Exception e) &#123; log.error(\"SQL语法错误\", e); return Response.fail(500, \"SQL语法错误\", e.getMessage()); &#125; @ExceptionHandler(MethodArgumentTypeMismatchException.class) public Result methodArgumentTypeMismatchException(MethodArgumentTypeMismatchException e) &#123; log.error(\"类型转换异常:&#123;&#125;\", e); return Response.fail(\"类型检查异常，请检查入参类型\"); &#125; @ExceptionHandler(MethodArgumentNotValidException.class) public Result&lt;String&gt; validatorException(MethodArgumentNotValidException e) &#123; log.debug(\"校验异常\", e); List&lt;ObjectError&gt; allErrors = e.getBindingResult().getAllErrors(); String error = allErrors.get(0).getDefaultMessage(); return Response.fail(error); &#125; /** * 针对Assert抛出的异常需要给前端进行显示 * * @param e * @return */ @ExceptionHandler(IllegalArgumentException.class) public Result&lt;String&gt; illegalArgumentException(IllegalArgumentException e) &#123; log.debug(\"校验异常\", e); return Response.fail(e.getMessage()); &#125;&#125; 需要注意的是, ExceptionHandler 的优先级比 ControllerAdvice 高, 即 Controller 抛出的异常如果既可以让 ExceptionHandler 标注的方法处理, 又可以让 ControllerAdvice 标注的类中的方法处理, 则优先让 ExceptionHandler 标注的方法处理. 处理404在上述过程中，如果发送异常，则会由统一异常进行管理，但是如果是404，SpringBoot不会抛出异常，而是跳转到error页面，如果没有error页面，则会返回whitepage，将错误信息打印出来。如果是做接口，返回的话不是很友好。 解决方案： spring.mvc.throw-exception-if-no-handler-found=truespring.resources.add-mappings=false 参考文章https://segmentfault.com/a/1190000006749441","categories":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://liuyiyou.cn/categories/spring-boot/"}],"tags":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://liuyiyou.cn/tags/spring-boot/"}]},{"title":"SpringBoot学习-控制器","slug":"SpringBoot学习-控制器","date":"2017-09-11T16:00:00.000Z","updated":"2019-04-17T13:44:08.077Z","comments":true,"path":"SpringBoot学习-控制器/","link":"","permalink":"http://liuyiyou.cn/SpringBoot学习-控制器/","excerpt":"","text":"在上一篇SpringBoot学习-初探中搭建了一个最简单SpringBoot程序，后续不再提供项目搭建截图，直接采用maven模式 内容 返回json 返回模板 Circular view path问题解决方案 使用fastjson代替jackson 返回json从spring4.0开始，Spring提供了@RestController注解，提供该注解是一个组合注解 @Controller &amp;&amp; @ResponseBody。SpringBoot常见方式是使用@RestController，在控制层加上该注解之后，默认返回json，而不需要额外的配置。 下面的两个方法，如果使用@Controller进行注解，会找对应模板下的Hello模板，但是使用@RestController进行注解的时候，直接返回内容@RestController@RequestMapping(\"/rest/\")public class HelloRestController &#123; @RequestMapping(\"hello\") public String sayHello() &#123; return \"Hello\"; &#125;&#125; 返回模板想要返回模板，需要加入对应的starter，以thymeleaf为例，首先需要加入如下依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 如果不加该依赖（获取其他依赖）会产生两个主要问题 404 Circular view path 异常： 404原因：如果没有添加对应的依赖，默认使用InterResourceViewResolver和JStlView，导致模板定位不准？ javax.servlet.ServletException: Circular view path [hello2]: would dispatch back to the current handler URL [/controller/hello2] again. Check your ViewResolver setup! (Hint: This may be the result of an unspecified view, due to default view name generation.) at org.springframework.web.servlet.view.InternalResourceView.prepareForRendering(InternalResourceView.java:205) ~[spring-webmvc-4.3.13.RELEASE.jar:4.3.13.RELEASE] at org.springframework.web.servlet.view.InternalResourceView.renderMergedOutputModel(InternalResourceView.java:145) ~[spring-webmvc-4.3.13.RELEASE.jar:4.3.13.RELEASE] at org.springframework.web.servlet.view.AbstractView.render(AbstractView.java:303) ~[spring-webmvc-4.3.13.RELEASE.jar:4.3.13.RELEASE] at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1286) ~[spring-webmvc-4.3.13.RELEASE.jar:4.3.13.RELEASE] at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1041) ~[spring-webmvc-4.3.13.RELEASE.jar:4.3.13.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:984) ~[spring-webmvc-4.3.13.RELEASE.jar:4.3.13.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:901) ~[spring-webmvc-4.3.13.RELEASE.jar:4.3.13.RELEASE] at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970) ~[spring-webmvc-4.3.13.RELEASE.jar:4.3.13.RELEASE] at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:861) ~[spring-webmvc-4.3.13.RELEASE.jar:4.3.13.RELEASE] Circular view path问题解决方案Circular view path 异常引发方式： 没有添加thymeleaf 如下所示： @Controller@RequestMapping(\"/controller/\")public class HelloController &#123; @RequestMapping(\"hello2\") public String hello2()&#123; return \"hello2\"; &#125; &#125; 原因：https://stackoverflow.com/questions/18813615/how-to-avoid-the-circular-view-path-exception-with-spring-mvc-test 当没有声明ViewResolver时，spring会给你注册一个默认的ViewResolver，就是JstlView的实例， 该对象继承自InternalResoureView。JstlView用来封装JSP或者同一Web应用中的其他资源，它将model对象作为request请求的属性值暴露出来, 并将该请求通过javax.servlet.RequestDispatcher转发到指定的URL.Spring认为， 这个view的URL是可以用来指定同一web应用中特定资源的，是可以被RequestDispatcher转发的。也就是说，在页面渲染(render)之前，Spring会试图使用RequestDispatcher来继续转发该请求。如下代码： if (path.startsWith(\"/\") ? uri.equals(path) : uri.equals(StringUtils.applyRelativePath(uri, path))) &#123; throw new ServletException(\"Circular view path [\" + path + \"]: would dispatch back \" + \"to the current handler URL [\" + uri + \"] again. Check your ViewResolver setup! \" + \"(Hint: This may be the result of an unspecified view, due to default view name generation.)\");&#125; 解决方法 添加thymeleaf 使用内置的InterResourceViewResolver，这个后续在集成jsp做模板的时候使用 使用fastjson代替jackson原因： 可能引发的中文乱码：这个在SpringBoot下很少发生 日期格式问题，jackson序列化的日期是long &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.35&lt;/version&gt;&lt;/dependency&gt; @SpringBootApplicationpublic class HelloApplication extends WebMvcConfigurerAdapter &#123; public static void main(String[] args) &#123; // 程序启动入口 // 启动嵌入式的 Tomcat 并初始化 Spring 环境及其各 Spring 组件 SpringApplication.run(HelloApplication.class, args); &#125; static String dateFormat = \"yyyy-MM-dd HH:mm:ss\"; @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; FastJsonHttpMessageConverter fastConverter = new FastJsonHttpMessageConverter(); FastJsonConfig fastJsonConfig = new FastJsonConfig(); SerializeConfig serializeConfig = SerializeConfig.globalInstance; serializeConfig.put(BigInteger.class, ToStringSerializer.instance); serializeConfig.put(Long.class, ToStringSerializer.instance); serializeConfig.put(Long.TYPE, ToStringSerializer.instance); serializeConfig.put(Date.class, new SimpleDateFormatSerializer(dateFormat)); fastJsonConfig.setSerializeConfig(serializeConfig); fastConverter.setFastJsonConfig(fastJsonConfig); converters.add(fastConverter); &#125;&#125;","categories":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://liuyiyou.cn/categories/spring-boot/"}],"tags":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://liuyiyou.cn/tags/spring-boot/"}]},{"title":"SpringBoot学习-初探","slug":"SpringBoot学习-初探","date":"2017-09-09T16:00:00.000Z","updated":"2019-05-13T08:46:37.378Z","comments":true,"path":"SpringBoot学习-初探/","link":"","permalink":"http://liuyiyou.cn/SpringBoot学习-初探/","excerpt":"","text":"前言本系列文章尽可能每章都是一个详细的知识点，浏览到这篇文章的人，能参考该文章对SpringBoot有一个详细的了解 内容 SpringBoot快速入门 从SpringMvc到SpringBoot SpringBoot优点 简化依赖：不再需要在pom中增加各种依赖，不再需要因为不同框架的不同版本而导致各种NoSuchMethod的异常 简化配置：不再需要在xml中进行各种配置 独立部署：内嵌tomcat和jetty，直接通过main方法即可启动，可打包成jar进行独立部署 提供生产就绪型功能，如指标，健康检查和外部配置 和SpringCloud等能进行良好的结合 SpringBoot缺点 封装得太彻底，开发人员对底层了解不够 出错排查比较麻烦 如果不使用约定配置，也会有一堆配置文件 SpringBoot快速入门本节参考官网文档：https://projects.spring.io/spring-boot/#quick-start 必要条件 IDE: 推荐使用idea，eclipse也可以，这里使用idea jdk版本： 推荐使用1.8 spring-boot版本： 2.0.7 构建工具： maven，也可以使用gradle，这里使用maven 用idea构建版本跟新成2.1.4 选择sdk版本 选择jdk版本、项目类型 选择相关组件。因为是快速入门，所以这里只选择一个web。截图中没有选择，需要注意,如果没有选择，则只有Spring-Core相关功能，MVC功能会缺失 项目构建成功后，会出现如下所示目录 修改HelloApplication.java, 并使用main方法启动，访问 http://localhost:8080/hello 即可查看效果 @SpringBootApplication@RestControllerpublic class HelloApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HelloApplication.class, args); &#125; @GetMapping(\"/\") public String hello() &#123; return \"success\"; &#125;&#125; 用maven构建如果不想使用idea工具搭建项目，可以使用maven方式，方式和常规maven项目一致，只是入口类和pom需要自己进行配置，建议使用 https://start.spring.io/ 进行配置，主要是方便，而且不容易出错 源码地址https://github.com/liuyiyou/cn.liuyiyou.springboot/tree/master/springboot-hello 参考文章http://tengj.top/2017/02/26/springboot1/","categories":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://liuyiyou.cn/categories/spring-boot/"}],"tags":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://liuyiyou.cn/tags/spring-boot/"}]},{"title":"冒泡排序","slug":"冒泡排序","date":"2015-01-05T16:00:00.000Z","updated":"2019-04-23T08:24:50.467Z","comments":true,"path":"冒泡排序/","link":"","permalink":"http://liuyiyou.cn/冒泡排序/","excerpt":"","text":"概述冒泡排序：它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名 动画演示:排序过程 算法原理冒泡排序算法的运作如下：（从后往前） 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较 算法分析时间复杂度若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数$$C$$和记录移动次数$$M$$均达到最小值:$$C_{min}=n-1$$,$$M_{min}=0$$。所以，冒泡排序最好的时间复杂度为$$O(n)$$ 。 若初始文件是反序的，需要进行$$n-1$$趟排序。每趟排序要进行$$n-i$$次关键字的比较($$1≤i≤n-1$$),且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值： $$C_{max} = \\left(n(n-1)\\over 2 \\right) = O(n^2)$$ $$M_{max} = \\frac{3n(n-1)}{2} = O(n^2)$$ 冒泡排序的最坏时间复杂度为$$O(n^2)$$ 。 综上，因此冒泡排序总的平均时间复杂度为$$O(n^2)$$ 算法稳定性冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。 算法描述package cn.liuyiyou.sort;/** * 冒泡排序： * User: liuyiyou * Date: 13-1-1 * Time: 下午4:04 */public class BubbleSort &#123; /** * 这个是冒泡排序，冒泡排序是待排序的数和后面相邻的数比较大小 * 注意内层循环中j的取值变化，之前i的初始值是1，j的临界值是array.length。 * @param array */ public static void bubbleSort1(int[] array)&#123; for (int i=0;i&lt;array.length;i++)&#123; for (int j = 0; j&lt;array.length-i-1;j++ )&#123; if (array[j] &gt; array[j+1])&#123; SortUtil.swap(array,j,j+1); &#125; &#125; SortUtil.print(array, i); &#125; &#125; public static void bubbleSort2(int[] array)&#123; for (int i=0;i&lt;array.length;i++)&#123; for (int j = 0; j&lt; i;j++ )&#123; if (array[i]&lt;array[j])&#123; SortUtil.swap(array,i,j); &#125; &#125; SortUtil.print(array, i); &#125; &#125; public static void bubbleSort3(int[] array) &#123; for (int i = 0; i &lt; array.length - 1; i++) &#123; // 最多做n-1趟排序 // 对当前无序区间score[0......length-i-1]进行排序(j的范围很关键，这个范围是在逐步缩小的) for (int j = 0; j &lt; array.length - i - 1; j++) &#123; if (array[j] &lt; array[j + 1]) &#123; // 把小的值交换到后面 SortUtil.swap(array, j, j + 1); &#125; &#125; SortUtil.print(array, i); &#125; &#125; public static void main(String [] args)&#123; int [] array = SortUtil.array; System.out.println(\"原始排序结果：\"); SortUtil.print(array); bubbleSort3(array); System.out.println(\"最终排序结果：\"); SortUtil.print(array); &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/tags/数据结构/"}]},{"title":"希尔排序","slug":"希尔排序","date":"2015-01-04T16:00:00.000Z","updated":"2019-04-23T08:24:31.970Z","comments":true,"path":"希尔排序/","link":"","permalink":"http://liuyiyou.cn/希尔排序/","excerpt":"","text":"概述希尔排序和直接插入排序一样，都是插入排序，但是它改进了直接插入排序，该方法又称缩小增量排序 算法原理希尔算法的运作如下：（从后往前） 先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内部进行直接插入排序，然后，取第二个增量d2&lt;d1重复上述分组和排序，直至所取的增量dt＝1，即所有记录放在同一组中进行直接插入排序为止。 一般的初次取序列的一半为增量，以后每次减半，直到增量为1。 算法流程图 算法分析时间复杂度希尔排序的时间复杂度和增量选取有关，如使用希尔增量时间复杂度为$$O(n^2)$$ ，而Hibbaard增量的希尔排序的时间复杂度为$$O(n^\\frac{3}{2})$$ ,希尔排序时间复杂度下届是$$nlog2n$$。希尔排序没有快速排序算法快$$O(nlogn)$$ 算法稳定性由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。 和直接排序进行比较来看一下希尔排序和快速排序的差别和联系 会发现基本思想和直接插入排序一模一样，只是多了一个曾脸的变化，即外面的while循环和那个increment = increment /2 //直接插入排序public static void insertSort1(int[] array) &#123; //从位置1开始，0做为哨兵 for (int i = 1; i &lt; array.length; i++) &#123; //保存当前位置到临时变量 int temp = array[i]; //将当前位置赋给紧邻的未排序的起点 int j = i; //如果未排序的数小于已排序的树 if (array[i - 1] &gt; array[i]) &#123; //向后移动一个位置 while (j &gt; 0 &amp;&amp; array[j - 1] &gt; temp) &#123; //只能是temp，不能是array[i] ,如果是array[i],在执行下面这句话的时候，array[i]会改的值被改变了 array[j] = array[j - 1]; j--; &#125; //将当前位置存放为i array[j] = temp; //同上，比如i为1的时候array[i]=3，array[j-1]为1，执行while里面的前移之后，array[j]=array[i]=3.而实际的情况应该是array[j] &#125; else &#123; System.out.println(i); &#125; &#125; &#125;//希尔排序public static void shellSort1(int[] array)&#123; //增量 ,初始一般为数组的一半，最后为1 int increment = array.length/2; //控制增量变化，一直到1 while (increment&gt;0)&#123; for (int i = increment ; i &lt; array.length; i++)&#123; //保存当前位置到临时变量 int temp = array[i]; //将当前位置赋给紧邻的未排序的起点 int j = i; //如果未排序的数小于已排序的树 if (array[i-increment]&gt;array[i])&#123; //向后移动increment个位置 while (j&gt;=increment &amp;&amp; array[j-increment]&gt; temp)&#123; array[j] = array[j-increment]; j = j - increment; &#125; //将当前位置存放为i array[j] = temp; //同上，比如i为1的时候array[i]=3，array[j-1]为1，执行while里面的前移之后，array[j]=array[i]=3.而实际的情况应该是array[j] &#125; else &#123; System.out.println(i); &#125; &#125; //增量为上一次的一半。因为是int类型，所以最后会到1（0就不进行除了） increment = increment/2; &#125; &#125; 算法描述package cn.liuyiyou.sort;/** * User: liuyiyou * Date: 13-1-1 * Time: 下午8:16 */public class ShellSort &#123; /** * 这个可以和前面的快速插入排序进行比较，会发现方法一模一样，只是快速插入的增量一直为1.而希尔排序增量是慢慢变小的。 * */ public static void shellSort1(int[] array)&#123; int increment = array.length/2; while (increment&gt;0)&#123; for (int i = increment ; i &lt; array.length; i++)&#123; int temp = array[i]; int j = i; if (array[i-increment]&gt;array[i])&#123; while (j&gt;=increment &amp;&amp; array[j-increment]&gt; temp)&#123; array[j] = array[j-increment]; j = j - increment; &#125; array[j] = temp; &#125; else &#123; System.out.println(i); &#125; &#125; increment = increment/2; &#125; &#125; public static void shellSort2(int[] array) &#123; int count = 0; int j = 0; int temp = 0; for (int increment = array.length / 2; increment &gt; 0; increment /= 2) &#123; count++; for (int i = increment; i &lt; array.length; i++) &#123; temp = array[i]; for (j = i; j &gt;= increment; j -= increment) &#123; if(temp &gt; array[j - increment])&#123; array[j] = array[j - increment]; &#125;else&#123; break; &#125; &#125; array[j] = temp; &#125; &#125; System.out.println(count); &#125; public static void shellSort3(int[] array) &#123; int j = 0; int temp = 0; int increment = array.length/2; while (increment&gt;0)&#123; for (int i = increment; i &lt; array.length; i++) &#123; temp = array[i]; j = i; while (j &gt;= increment) &#123; if(temp &gt; array[j - increment])&#123; array[j] = array[j - increment]; &#125;else&#123; break; &#125; j = j - increment; &#125; array[j] = temp; &#125; increment = increment/2; &#125; &#125; public static void main(String[] args) &#123; int [] array = SortUtil.array; System.out.println(\"原始排序结果：\"); SortUtil.print(array); shellSort1(array); System.out.println(\"最终排序结果：\"); SortUtil.print(array); &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/tags/数据结构/"}]},{"title":"快速排序","slug":"快速排序","date":"2015-01-03T16:00:00.000Z","updated":"2019-04-23T08:24:27.328Z","comments":true,"path":"快速排序/","link":"","permalink":"http://liuyiyou.cn/快速排序/","excerpt":"","text":"概述通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 算法原理通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 算法流程图动画演示:排序过程 算法分析时间复杂度时间复杂度：O（n*lgn） 最坏：O（n^2） 空间复杂度：O（n*lgn） 算法稳定性不稳定。 代码","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/tags/数据结构/"}]},{"title":"选择排序","slug":"选择排序","date":"2015-01-02T16:00:00.000Z","updated":"2019-04-23T08:23:56.726Z","comments":true,"path":"选择排序/","link":"","permalink":"http://liuyiyou.cn/选择排序/","excerpt":"","text":"概述选择排序：每一趟从待排序的数据元素中选出最小（或最大）的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。 原理：选择排序很简单，他的步骤如下： 从左至右遍历，找到最小(大)的元素，然后与第一个元素交换。 从剩余未排序元素中继续寻找最小（大）元素，然后与第二个元素进行交换。 以此类推，直到所有元素均排序完毕。 动画演示: 具体的排序过程 算法分析时间复杂度若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数$$C$$和记录移动次数$$M$$均达到最小值:$$C_{min}=n-1$$,$$M_{min}=0$$。所以，冒泡排序最好的时间复杂度为$$O(n)$$ 。 若初始文件是反序的，需要进行$$n-1$$趟排序。每趟排序要进行$$n-i$$次关键字的比较($$1≤i≤n-1$$),且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值： $$C_{max} = \\left(n(n-1)\\over 2 \\right) = O(n^2)$$ $$M_{max} = \\frac{3n(n-1)}{2} = O(n^2)$$ 冒泡排序的最坏时间复杂度为$$O(n^2)$$ 。 综上，因此冒泡排序总的平均时间复杂度为$$O(n^2)$$ 分析 选择排序需要花费 (N – 1) + (N – 2) + … + 1 + 0 = N(N- 1) / 2 ~ N2/2次比较 和 N-1次交换操作。 对初始数据不敏感，不管初始的数据有没有排好序，都需要经历N2/2次比较，这对于一些原本排好序，或者近似排好序的序列来说并不具有优势。在最好的情况下，即所有的排好序，需要0次交换，最差的情况，倒序，需要N-1次交换。 数据交换的次数较少，如果某个元素位于正确的最终位置上，则它不会被移动。在最差情况下也只需要进行N-1次数据交换，在所有的完全依靠交换去移动元素的排序方法中，选择排序属于比较好的一种。 算法稳定性不稳定 算法实现可以分为两大部分： 找到待排序数组中第i小的元素 将该元素与i处的元素进行交换 public static int findMinIndex(int[] array, int i) &#123; int minIndex = i; for (int j = i + 1; j &lt; array.length; j++) &#123; if (array[minIndex] &gt; array[j]) &#123; minIndex = j; &#125; &#125; System.out.println(\"第\" + (i) + \"小的\" + array[minIndex]); return minIndex; &#125;public static void swap(int[] array, int i, int minIndex) &#123; int temp = array[i]; array[i] = array[minIndex]; array[minIndex] = temp; &#125;public static void selectSort2(int[] array) &#123; for (int i = 0; i &lt; array.length; i++) &#123; int minIndex = findMinIndex(array, i); swap(array, i, minIndex); &#125; &#125; package cn.liuyiyou.sort;// 每一趟从待排序的数据元素中选出最小（或最大）的一个元素，顺序放在已排好序的数列的最后，//直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。public class SelectSort &#123; public static void selectSort3(int[] array) &#123; for (int i = 0; i &lt; array.length; i++) &#123; //默认当前位置最小 int minIndex = i; for (int j = i + 1; j &lt; array.length; j++) &#123; //如果未排序的元素比当前元素小，则将该元素的索引赋给最小元素的索引 if (array[minIndex] &gt; array[j]) minIndex = j; &#125; //第i个元素与最小元素进行交换 int temp = array[i]; array[i] = array[minIndex]; array[minIndex] = temp; &#125; &#125; //这个就是稳定算法了 public static void selectSort2(int array[]) &#123; int minIndex = 0; if ((array == null) || (array.length == 0)) return; for (int i = 0; i &lt; array.length; i++) &#123; minIndex = i;//无序区的最小数据数组下标 for (int j = i + 1; j &lt; array.length; j++) &#123;//在无序区中找到最小数据并保存其数组下标 if (array[j] &lt; array[minIndex]) &#123; minIndex = j; &#125; &#125; if (minIndex != i) &#123;//如果不是无序区的最小值位置且不是默认的第一个数据，则交换之。 //第i个元素与最小元素进行交换 int temp = array[i]; array[i] = array[minIndex]; array[minIndex] = temp; &#125; &#125; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/tags/数据结构/"}]},{"title":"插入排序","slug":"插入排序","date":"2015-01-01T16:00:00.000Z","updated":"2019-04-23T08:24:21.805Z","comments":true,"path":"插入排序/","link":"","permalink":"http://liuyiyou.cn/插入排序/","excerpt":"","text":"概述插入排序包括 直接插入排序和希尔排序 直接插入排序的基本操作是：假设第一个元素是有序的，每次从无序表中取出第一个元素，把它插入到有序表的合适位置，从而得到一个新的，记录数增1的有序表 第一种方式： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素小于前面的元素（已排序），则依次与前面元素进行比较如果小于则交换，直到找到大于该元素的就则停止； 如果该元素大于前面的元素（已排序），则重复步骤2 重复步骤2~4 直到所有元素都排好序 。 第二种方式： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素小于前面的元素（已排序），则依次与前面元素进行比较如果小于则继续与前面的的数比较，直到找到大于该元素的就则停止； 将该位置后面的元素整体移动一位，再交换 重复步骤2~4 直到所有元素都排好序 。 两种方式，第一种是逐个交换，第二种是先找到，再整体后移，最后进行交换 动画演示:排序过程 具体步骤： 算法原理直接插入排序算法的运作如下 第一个元素默认有序，从第二个元素与它前面的元素进行比较 如果第二个元素比第一个元素小，则将该元素用临时变量来保存，并将他前面的元素进行后移 一直移动到比该元素小的位置，将元素插入到该位置 算法分析时间复杂度若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数$$C$$和记录移动次数$$M$$均达到最小值:$$C_{min}=n-1$$, $$M_{min}=0$$。所以，冒泡排序最好的时间复杂度为$$O(n) 。 若初始文件是反序的，需要进行$$n-1$$趟排序。每趟排序要进行$$n-i$$次关键字的比较($$1≤i≤n-1$$),且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：$$C_{max} = \\left(n(n-1)\\over 2 \\right) = O(n^2)$$$$M_{max} = \\frac{3n(n-1)}{2} = O(n^2)$$直接排序的最坏时间复杂度为$$O(n^2)$$ 。 综上，因此冒泡排序总的平均时间复杂度为$$O(n^2)$$ ，空间复杂度为$$O(1)$$ 算法稳定性冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。 算法描述package cn.liuyiyou.sort; /** * 插入排序：插入排序包括 直接插入排序和希尔排序 直接插入排序的基本操作是：将一个记录插入到已排好序的有序列表中，从而得到一个新的，记录数增1的有序表。 */ public class InsertSort &#123; //第一种：比前面的元素小的时候，先交换 public static void insertSort2(int[] array) &#123; for (int i = 1; i &lt; array.length; i++) &#123; // 从i个元素开始，依次与i之前的元素进行比较 for (int j = i; j &gt; 0; j--) &#123; if (array[j - 1] &gt; array[j]) &#123; int temp = array[j - 1]; array[j - 1] = array[j]; array[j] = temp; &#125; else &#123; //快速退出 break; &#125; &#125; &#125; &#125; //先后移，再交换 public static void insertSort3(int[] array) &#123; for (int i = 1; i &lt; array.length; i++) &#123; int temp = array[i]; //这个可以放在if里面 int j = i; if (array[i] &lt;array[i - 1] ) &#123; for ( ; j &gt; 0 &amp;&amp; temp &lt; array[j - 1] ; j--) &#123; array[j] = array[j - 1]; &#125; array[j] = temp; &#125; &#125; &#125; //while实现 public static void insertSort2(int[] array)&#123; //从位置1开始，0做为哨兵 for (int i = 1 ; i &lt; array.length; i++)&#123; //保存当前位置到临时变量 int temp = array[i]; //将当前位置赋给紧邻的未排序的起点 int j = i; //如果未排序的数小于已排序的树 if (array[i-1]&gt;array[i])&#123; //向后移动一个位置 while (j&gt;0 &amp;&amp; array[j-1]&gt; temp)&#123; //只能是temp，不能是array[i] ,如果是array[i],在执行下面这句话的时候，array[i]会改的值被改变了 array[j] = array[j-1]; j--; &#125; //将当前位置存放为i array[j] = temp; //同上，比如i为1的时候array[i]=3，array[j-1]为1，执行while里面的前移之后，array[j]=array[i]=3.而实际的情况应该是array[j] &#125; &#125; &#125; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuyiyou.cn/tags/数据结构/"}]}]}