title: JAVA并发编程常识
date: 2015-11-01
categories : 
  - java
tags : 
  - java
  - 并发
---

本文摘自虚极(梁飞)的某个PPT


## JVM内存模型

### 堆：

- 所有对象全部放在共享堆空间中
- 对象的属性在共享堆空间内
	- 堆内存单字节对齐，short不变

### 栈：

- 每个线程都有独立的线程栈空间
- 线程栈只存基本类型和对象地址
	- 栈内存4字节对齐，short变int
	- 对象地址4字节，引用堆空间
- 方法中局部变量在线程栈空间内
	- 局部变量不会竞争，线程安全
	- 方法参数在栈顶交叉，不拷贝
	- 栈顶寄存，减少中间状态读取PC指针记录当前执行位置


## 原子性

### 对象类型：

- 对象地址原子读写，线程安全
- 并发读不可变状态，线程安全
- 并发读写可变状态，非线程线程

### 基本类型：
- int,char数值读写，线程安全
- long,double高低位，非线程安全
- i++等组合操作，非线程安全


## 可见性

- final
初始化final字段确保可见性

- volatile
读写volatile字段确保可见性

- synchronized
同步块内读写字段确保可见性

- happen before
遵守happen before次序可见性



## 可排序性

### Happen Before 法则

- 程序次序法则
如果A一定在B之前发生，则happen before,

- 监视器法则
对一个监视器的解锁一定发生在后续对同一监视器加锁之前

- Volatie变量法则
写volatile变量一定发生在后续对它的读之前

- 线程启动法则
Thread.start一定发生在线程中的动作之前

- 线程终结法则
线程中的任何动作一定发生在括号中的动作之前（其他线程检测到这个线程已经终止，从Thread.join调用成功返回，Thread.isAlive()返回false）

- 中断法则
一个线程调用另一个线程的interrupt一定发生在另一线程发现中断之前。

- 终结法则
一个对象的构造函数结束一定发生在对象的finalizer之前

- 传递性
A发生在B之前，B发生在C之前，A一定发生在C之前。 


## 系统内存

### MESI协议:

- Modified

    - 本CPU写，则直接写到Cache，不产生总线事务；其它CPU写，则不涉及本CPU的Cache，其它CPU读，则本CPU需要把Cache line中的数据提供给它，而不是让它去读内存。 
 
- Exclusive

    - 只有本CPU有该内存的Cache，而且和内存一致。 本CPU的写操作会导致转到Modified状态。 

- Shared
    
    - 多个CPU都对该内存有Cache，而且内容一致。任何一个CPU写自己的这个Cache都必须通知其它的CPU。 

- Invalid

    - 一旦Cache line进入这个状态，CPU读数据就必须发出总线事务，从内存读。 