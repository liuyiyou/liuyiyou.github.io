title: 插入排序
date: "2015-01-02"
categories: 
  - 数据结构
tags:
    - 数据结构
---

## 概述

插入排序包括 直接插入排序和希尔排序 

直接插入排序的基本操作是：假设第一个元素是有序的，每次从无序表中取出第一个元素，把它插入到有序表的合适位置，从而得到一个新的，记录数增1的有序表


第一种方式：

1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素小于前面的元素（已排序），则依次与前面元素进行比较如果小于则交换，直到找到大于该元素的就则停止；
4. 如果该元素大于前面的元素（已排序），则重复步骤2
5. 重复步骤2~4 直到所有元素都排好序 。


第二种方式：

1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素小于前面的元素（已排序），则依次与前面元素进行比较如果小于则继续与前面的的数比较，直到找到大于该元素的就则停止；
4. 将该位置后面的元素整体移动一位，再交换
5. 重复步骤2~4 直到所有元素都排好序 。


两种方式，第一种是逐个交换，第二种是先找到，再整体后移，最后进行交换



### 动画演示:

排序过程

![console](/images/ds/insertSort.gif)

具体步骤：

![console](/images/ds/insertSort2.gif)


##算法原理

直接插入排序算法的运作如下

- 第一个元素默认有序，从第二个元素与它前面的元素进行比较
- 如果第二个元素比第一个元素小，则将该元素用临时变量来保存，并将他前面的元素进行后移
- 一直移动到比该元素小的位置，将元素插入到该位置

##算法分析

###时间复杂度

若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数$$C$$和记录移动次数$$M$$均达到最小值:$$C_{min}=n-1$$, $$M_{min}=0$$。所以，冒泡排序最好的时间复杂度为$$O(n) 。

若初始文件是反序的，需要进行$$n-1$$趟排序。每趟排序要进行$$n-i$$次关键字的比较($$1≤i≤n-1$$),且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：



$$C_{max} = \left(n(n-1)\over 2 \right) = O(n^2)$$

$$M_{max} = \frac{3n(n-1)}{2} = O(n^2)$$

直接排序的最坏时间复杂度为$$O(n^2)$$ 。

综上，因此冒泡排序总的平均时间复杂度为$$O(n^2)$$ ，空间复杂度为$$O(1)$$

### 算法稳定性

冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。

### 算法描述


```java

package cn.liuyiyou.sort;

    /**
     * 插入排序：插入排序包括 直接插入排序和希尔排序
     直接插入排序的基本操作是：将一个记录插入到已排好序的有序列表中，从而得到一个新的，记录数增1的有序表。
     */
    public class InsertSort {

        //第一种：比前面的元素小的时候，先交换
        public static void insertSort2(int[] array) {

            for (int i = 1; i < array.length; i++) {
                // 从i个元素开始，依次与i之前的元素进行比较
                for (int j = i; j > 0; j--) {
                    if (array[j - 1] > array[j]) {
                        int temp = array[j - 1];
                        array[j - 1] = array[j];
                        array[j] = temp;
                    } else {
                        //快速退出
                        break;
                    }
                }
            }
        }

        //先后移，再交换
        public static void insertSort3(int[] array) {
            for (int i = 1; i < array.length; i++) {
                int temp = array[i];  //这个可以放在if里面
                int j = i;
                if (array[i] <array[i - 1] ) {
                    for ( ; j > 0 && temp < array[j - 1] ; j--) {
                        array[j] = array[j - 1];
                    }
                    array[j] = temp;
                }
            }
        }

        //while实现
        public static void insertSort2(int[] array){

            //从位置1开始，0做为哨兵
            for (int i = 1 ; i < array.length; i++){
                //保存当前位置到临时变量
                int temp = array[i];
                //将当前位置赋给紧邻的未排序的起点
                int j = i;
                //如果未排序的数小于已排序的树
                if (array[i-1]>array[i]){
                    //向后移动一个位置
                    while (j>0 && array[j-1]> temp){     
                        //只能是temp，不能是array[i] ,如果是array[i],在执行下面这句话的时候，array[i]会改的值被改变了
                        array[j] = array[j-1];
                        j--;
                    }
                    //将当前位置存放为i
                    array[j] = temp;    
                    //同上，比如i为1的时候array[i]=3，array[j-1]为1，执行while里面的前移之后，array[j]=array[i]=3.而实际的情况应该是array[j]
                } 
            }
        }

    }


```
