title: 选择排序
date: "2015-01-03"
categories: 
  - 数据结构
tags:
    - 数据结构
---


### 概述

选择排序：每一趟从待排序的数据元素中选出最小（或最大）的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。

### 原理：

选择排序很简单，他的步骤如下：

1. 从左至右遍历，找到最小(大)的元素，然后与第一个元素交换。
2. 从剩余未排序元素中继续寻找最小（大）元素，然后与第二个元素进行交换。
3. 以此类推，直到所有元素均排序完毕。


### 动画演示:

![console](/images/ds/selectSort.gif)


### 具体的排序过程

![console](/images/ds/selectSort2.jpg)

## 算法分析

### 时间复杂度

若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数$$C$$和记录移动次数$$M$$均达到最小值:$$C_{min}=n-1$$,$$M_{min}=0$$。所以，冒泡排序最好的时间复杂度为$$O(n)$$ 。

若初始文件是反序的，需要进行$$n-1$$趟排序。每趟排序要进行$$n-i$$次关键字的比较($$1≤i≤n-1$$),且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：


$$C_{max} = \left(n(n-1)\over 2 \right) = O(n^2)$$

$$M_{max} = \frac{3n(n-1)}{2} = O(n^2)$$

冒泡排序的最坏时间复杂度为$$O(n^2)$$ 。

综上，因此冒泡排序总的平均时间复杂度为$$O(n^2)$$ 


### 分析

- 选择排序需要花费 (N – 1) + (N – 2) + … + 1 + 0 = N(N- 1) / 2 ~ N2/2次比较 和 N-1次交换操作。

- 对初始数据不敏感，不管初始的数据有没有排好序，都需要经历N2/2次比较，这对于一些原本排好序，或者近似排好序的序列来说并不具有优势。在最好的情况下，即所有的排好序，需要0次交换，最差的情况，倒序，需要N-1次交换。

- 数据交换的次数较少，如果某个元素位于正确的最终位置上，则它不会被移动。在最差情况下也只需要进行N-1次数据交换，在所有的完全依靠交换去移动元素的排序方法中，选择排序属于比较好的一种。


### 算法稳定性

不稳定

### 算法实现


可以分为两大部分：

1. 找到待排序数组中第i小的元素
2. 将该元素与i处的元素进行交换


```java

public static int findMinIndex(int[] array, int i) {
        int minIndex = i;
        for (int j = i + 1; j < array.length; j++) {
            if (array[minIndex] > array[j]) {
                minIndex = j;
            }
        }
        System.out.println("第" + (i) + "小的" + array[minIndex]);
        return minIndex;
    }

public static void swap(int[] array, int i, int minIndex) {
        int temp = array[i];
        array[i] = array[minIndex];
        array[minIndex] = temp;

    }
public static void selectSort2(int[] array) {
        for (int i = 0; i < array.length; i++) {
            int minIndex = findMinIndex(array, i);
            swap(array, i, minIndex);
        }
    }

```




```java

package cn.liuyiyou.sort;

// 每一趟从待排序的数据元素中选出最小（或最大）的一个元素，顺序放在已排好序的数列的最后，
//直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。
public class SelectSort {


    public static void selectSort3(int[] array) {
        for (int i = 0; i < array.length; i++) {
            //默认当前位置最小
            int minIndex = i;
            for (int j = i + 1; j < array.length; j++) {
                //如果未排序的元素比当前元素小，则将该元素的索引赋给最小元素的索引
                if (array[minIndex] > array[j])
                    minIndex = j;
            }
            //第i个元素与最小元素进行交换
            int temp = array[i];
            array[i] = array[minIndex];
            array[minIndex] = temp;
        }
    }


    //这个就是稳定算法了
    public static void selectSort2(int array[]) {
        int minIndex = 0;
        if ((array == null) || (array.length == 0)) return;
        for (int i = 0; i < array.length; i++) {
            minIndex = i;//无序区的最小数据数组下标
            for (int j = i + 1; j < array.length; j++) {//在无序区中找到最小数据并保存其数组下标
                if (array[j] < array[minIndex]) {
                    minIndex = j;
                }
            }
            if (minIndex != i) {//如果不是无序区的最小值位置且不是默认的第一个数据，则交换之。
                //第i个元素与最小元素进行交换
                       int temp = array[i];
                       array[i] = array[minIndex];
                       array[minIndex] = temp;
            }
        }
    }

}

```

