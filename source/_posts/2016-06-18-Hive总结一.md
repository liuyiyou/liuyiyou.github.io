date: "2016-06-18"
categories: 
  - 大数据
title: 2016-06-18-Hive总结(1)
tags : 
 - hive
---


在添加字段后，如果分区不删除，新字段在hdfs存在，但是无法查询出来


http://blog.csdn.net/lxpbs8851/article/details/17118841

http://blog.csdn.net/xiao_jun_0820/article/details/45560591


# 查询

SELECT ... WHERE ...

```sql

SELECT * FROM wdi WHERE indicator_name = 'Trade (% of GDP)';

```


SELECT ... ORDER BY ... 

Hive中的order by跟传统的sql语言中的order by作用是一样的，会对查询的结果做一次全局排序，所以说，只有hive的sql中制定了order by所有的数据都会到同一个reducer进行处理（不管有多少map，也不管文件有多少的block只会启动一个reducer）。但是对于大量数据这将会消耗很长的时间去执行。
    
这里跟传统的sql还有一点区别：如果指定了hive.mapred.mode=strict（默认值是nonstrict）,这时就必须指定limit来限制输出条数，原因是：所有的数据都会在同一个reducer端进行，数据量大的情况下可能不能出结果，那么在这样的严格模式下，必须指定输出的条数。


```sql

SELECT `country_name`, `2011` AS trade_2011 FROM wdi WHERE   indicator_name = 'Trade (% of GDP)' AND   `2011` IS NOT NULL
ORDER BY trade_2011 DESC;

```

SELECT ... SORT BY ... 

Hive中指定了sort by，那么在每个reducer端都会做排序，也就是说保证了局部有序（每个reducer出来的数据是有序的，但是不能保证所有的数据是有序的，除非只有一个reducer），好处是：执行了局部排序之后可以为接下去的全局排序提高不少的效率（其实就是做一次归并排序就可以做到全局排序了）。

```sql

SELECT `country_name`, `2011` AS trade_2011 FROM wdi WHERE   indicator_name = 'Trade (% of GDP)' AND   `2011` IS NOT NULL
SORT BY trade_2011 DESC;

```

SELECT ... CLUSTER BY ... 

cluster by的功能就是distribute by和sort by相结合，如下2个语句是等价的：





SELECT ... DISTRIBUTE BY 

```sql

SELECT country_name, indicator_name, `2011` AS trade_2011 FROM wdi WHERE   (indicator_name = 'Trade (% of GDP)' OR   indicator_name = 'Broad money (% of GDP)') AND
  `2011` IS NOT NULL
  DISTRIBUTE BY indicator_name;

```


```sql

SELECT country_name, indicator_name, `2011` AS trade_2011 FROM wdi WHERE   (indicator_name = 'Trade (% of GDP)' OR   indicator_name = 'Broad money (% of GDP)') AND
  `2011` IS NOT NULL
  DISTRIBUTE BY indicator_name   SORT BY indicator_name;

 ``` 



JOIN

```sql

SELECT o.name FROM oecd_countries o JOIN nato_countries n ON n.name=o.name;

```

FULL OUTER JOIN 
LEFT OUTER JOIN 
RIGHT OUTER JOIN




T extFile
SequenceFile RCFile
ORC
Parquet