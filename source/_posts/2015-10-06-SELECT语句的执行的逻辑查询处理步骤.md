date: "2015-10-06"
title:  "SELECT语句的执行的逻辑查询处理步骤"
categories: 
  - mysql
tags:
    - mysql
---


SELECT语句的执行的逻辑查询处理步骤：

```sql

(8)	SELECT (9)DISTINCT
(11)	<TOP_specification> <select_list>
(1) 	FROM <left_table>
(3)	<join_type> JOIN <right_table>
(2)	ON <join_condition>
(4)	WHERE <where_condition>
(5)	GROUP BY <group_by_list>
(6)	WITH {CUBE | ROLLUP}
(7)	HAVING <having_condition>
(10)	ORDER BY <order_by_list>


```

注意：

1. 如果最上层的列中包含汇总函数，则每left join 一次，汇总的函数列会乘以2

2. 多个连接查询的时候，Group by 只能有一个（这个不是字面意思）

```sql

select sum(a.click) from a     #假设click为1，则第一次leftjoin之后为1，第二次leftjoin后为2
left  join b 
on a.id = b.id
left join c  # group by a.id 不能写在这里
on a.id = c.id
grouop by a.id

```

每个步骤产生一个虚拟表，该虚拟表被用作下一个步骤的输入。只有最后一步生成的表返回给调用者。如
果没有某一子句，则跳过相应的步骤。

1. FROM:对FROM子句中的前两个表执行笛卡尔积，生成虚拟表VT1。

2. ON:对VT1应用ON筛选器。只有那些使<join_condition>为真的行才被插入VT2。

3. OUTER(JOIN):如果指定了OUTER JOIN，保留表中未找到匹配的行将作为外部行添加到VT2，生成VT3。如果FROM子句包含两个以上的表，则对上一个联接生成的结果表和下一个表重复执行步骤1到步骤3，直到处理完所有的表为止。

4. 对VT3应用WHERE筛选器。只有使<where_condition>为TRUE的行才被插入VT4。

5. GROUP BY:按GROUP BY 子句中的列列表对VT4中的行分组，生成VT5。

6. CUBEROLLUP:把超组插入VT5，生成VT6。

7. HAVING:对VT6应用HAVING筛选器。只有使<having_condition>为TRUE的组才会被插入VT7。

8. SELECT:处理SELECT列表，产生VT8。

9. DISTINCT:将重复的行从VT8中移除，产生VT9。

10. ORDER BY:将VT9中的行按ORDER BY子句中的列列表排序，生成一个有表(VC10)。

11. TOP:从VC10的开始处选择指定数量或比例的行，生成表VT11,并返回给调用者。